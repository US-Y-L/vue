# day01

# 一、框架的介绍

## 1.什么是框架

框架，framework，它是一个网站的半成品，能够让开发人员能够专注于业务逻辑的处理。

## 2.vue框架

作者：尤雨溪

官网：https://cn.vuejs.org/

渐进式的Javascript框架

## 3.第四阶段主要学习内容

vue框架

​	vue、路由、vue-cli脚手架、axios、stylus、UI库、vuex状态管理、typescript、服务器端渲染

react框架

​	react、jsx语法糖、脚手架、路由

## 4.vue框架入门

vue两大核心：

数据驱动页面

组件化开发

### (1)优点

①体积小

②运行速度快（轻量级框架）

③虚拟DOM机制

④指令系统

⑤组件化开发

⑥生态系统繁荣

### (2)缺点

①兼容性，不兼容ie8

②报错相对来说不是特别的清晰

### (3)vue框架介绍

Vue (读音 /vjuː/，类似于 **view**) 是一套用于==构建用户界面==的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以==自底向上==逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的==单页应用==提供驱动。

### (4)安装vue

①直接引入外部js

```
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
```

②npm安装

```
npm i vue
```

安装好之后直接引入

```
<script src="./node_modules/vue/dist/vue.js"></script>
```

使用npm安装或者初始化项目前，一定要确认是否设置淘宝镜像地址（这样下载速度会比较快）

```
npm config set registry https://registry.npm.taobao.org
```

# 二、框架基本使用

## 1.实例化vue

```
new Vue({配置选项})
```

el:设置vue的作用范围，一般使用的id选择器，能够保证唯一性

el的挂载点不能是HTML、body这样的标签，应该是一个普通标签

## 2.设置初始数据

```
new Vue({
	el:"#app",
	data:{
		msg:"这里是初始数据"
	}
})
```

## 3.函数的声明和使用

自定义函数在methods选项中进行声明

```
new Vue({
	el:"",
	data:{},
	methods:{
		函数名称:function(){},
		函数名称N(){}
	}
})
```

使用自定义函数要在vue的挂载点内

```
<div id="app">
    {{ 函数名称() }}
</div>
```

# 三、指令系统

## 1.内容展示

(1)文本插值语法 {{ }}

mustache语法，双花括号内，可以写单行js语法

```
<p>{{ 10 + 20 }}</p>
<p>{{ status ? '已登录' : '未登录' }}</p>
<p>{{ '欢迎：' + name }}</p>
<p>欢迎：{{name}}</p>

```

vue中的指令都是以v-开头，都写在标签的开始标签上，作为一个属性去使用。

```
<标签名 指令=“”></标签名>

```

(2)v-text

v-text会把指定的内容展示到指定标签内部，类似原生JS中的innerText

(3)v-html

v-html会把指定的内容展示到指定标签内部，同时，它可以解析html语法，类似原生js中的innerHTML

文本插值语法和v-text、v-html的区别

1.它们都可以在页面中展示指定的内容

2.不同的是，v-text和v-html用于展示固定内容，如果要展示内容是某段文字中的一部分时，要使用文本插值语法。

```
<p v-text='name'></p>
<p v-html="name"></p>

```

## 2.条件判断

(1)v-if

​	v-if、v-else

​	v-if、v-else-if

单路分支

```
<标签 v-if="布尔值或者条件表达式"></标签>

```

如果布尔值或者条件表达式返回值为true，指定的标签会在页面结构中存在，否则就不存在。

双路分支

```
<标签1 v-if="布尔值或者条件表达式"></标签1>
<标签2 v-else></标签2>

```

多路分支

```
<标签1 v-if="布尔值或者条件表达式"></标签1>
<标签2 v-else-if="布尔值或者条件表达式N"></标签2>
...
<标签2 v-else></标签2>

```

(2)v-show

```
<标签1 v-show="布尔值或者条件表达式"></标签1>

```

不论布尔值或者条件表达式的返回值是什么，标签都会在页面结构中存在

当布尔值或者条件表达式的返回值为true时，标签会在页面结构中显示

当布尔值或者条件表达式的返回值为false时，会给标签添加一个display：none属性

v-if 惰性加载，满足条件了才会在页面结构存在指定的标签

v-show 只是改变了display属性，如果需要频繁的控制元素显示/不显示时，推荐使用v-show

==v-show不能和v-else配合使用==

## 3.事件绑定

```
<标签 v-on:事件名="一行js代码或者自定义函数名称"></标签>

```

可以简写成：

```
<标签 @事件名="一行js代码或者自定义函数名称"></标签>

```

## 4.属性绑定

### (1)普通属性绑定

当需要让标签的属性按照既定的规律进行变化时，可以通过v-bind进行绑定，这样属性绑定的变量值发生变化后，对应的属性也会跟着进行变化。

```
<标签 v-bind:属性名=“属性值”></标签>

```

可以简写成

```
<标签 :属性名=“属性值”></标签>

```

示例代码：

```vue
<div id="app">
    <img v-bind:src="arr[showidx]" />
    <button @click="showidx--">上一张</button>
    <button @click="showidx++">下一张</button>
</div>
<script>
    var vm = new Vue({
        el:"#app",
        data:{
            showidx:0,
            arr:[
                '3.jpg',
                '2.jpeg',
                '1.jpg'
            ]
        },
        methods: {
            //下一张的点击事件
            next(){
                if(this.showidx >= (this.arr.length-1)){
                    return;//不能让showidx数组下标无条件的累加，return之后的代码就不再执行了
                }
                this.showidx++;
            },
            //上一张的点击事件
            prev(){
                if(this.showidx<=0){
                    return;
                }
                this.showidx--;
            }
        }
    })
</script>

```

此案例中，showidx就是要展示图片的下标值，当下标值发生变化时，就会根据下标从数组中获取对应的图片地址并绑定给src属性，数据变化后，页面会自动重新渲染。

### (2)特殊属性绑定（动态样式绑定）

#### style

①变量的写法

```vue
<div id="app">
    <p :style="styleFont">破纪录！袁隆平团队双季稻晚稻亩产911.7公斤</p>
    <button @click="changeStyle('red')">红色</button>
    <button @click="changeStyle('blue')">蓝色</button>
</div>
<script>
	new Vue({
		el:"#app",
		data:{
			styleFont:{color:'red'}
		},
		methods:{
			changeStyle(color){
				this.styleFont = { color }
			}
		}
	})
</script>

```

②对象的写法

```
<p :style="{color:fontc,fontSize:'20px'}">破纪录！袁隆平团队双季稻晚稻亩产911.7公斤</p>
<p :style="{color:fontc,'font-size':'20px'}">破纪录！袁隆平团队双季稻晚稻亩产911.7公斤</p>

```

在对象写法中，属性名如果是多个单词，比如font-size、background-color、margin-left等，vue中需要把横杠和小写字母转换成大写字母：fontSize、backgroundColor、marginLeft。

③数组的写法

```
<p :style="[styleFont,styleSize]">破纪录！袁隆平团队双季稻晚稻亩产911.7公斤</p>

```

style的数组写法中，每一个数组元素都是一个变量，表示此标签可以使用多个行内样式。

#### class

①变量的写法

```vue
<style>
	.red{ color:red }
</style>
<div id="app">
	<p :class="className">港府公报：行政长官林郑月娥明起访问北京、广州和深圳</p>
</div>
<script>
	new Vue({
		el:"#app",
		data:{ className:'red' }
	})
</script>

```

②对象的写法

```vue
<style>
	.big{ font-size:40px; }
    .small{ font-size:15px;}
</style>
<div id="app">
	<p :class="{big:false,small:true}">港府公报：行政长官林郑月娥明起访问北京、广州和深圳</p>
</div>
<script>
	new Vue({
		el:"#app"
	})
</script>

```

布尔值或者表达式的结果为true时，表示使用指定的class属性，否则就不使用指定的class属性

③数组的写法

```vue
<style>
	.big{ font-size:40px; }
    .red{color:red;}
</style>
<div id="app">
	<p :class="['big','red']">港府公报：行政长官林郑月娥明起访问北京、广州和深圳</p>
</div>
<script>
	new Vue({
		el:"#app"
	})
</script>

```

## 5.列表渲染（循环）

v-for

语法格式：

```
<标签名 v-for="每次遍历的元素的变量名 of 数据源" ></标签名>

```

(1)数组

```
<标签名 v-for="(每次遍历的数组元素的变量名,遍历元素的下标) of 数据源" ></标签名>

```

(2)对象

```
<标签名 v-for="(每次遍历键值对中的键值,每次遍历键值对中的键名,每次遍历键值对的下标) of 数据源"></标签名>

```

(3)整数

```
<标签名 v-for="每次遍历键值对中的键值 of 整数值"></标签名>

```

如果想让某个标签遍历指定次数，可以直接遍历一个整数值，默认从1开始，每次递增1

示例代码：

```vue
<div id="app">
    <!-- 遍历数组，最多支持两个参数，第一个是元素，第二个是下标 -->
    <button v-for="(item,index) in arr">{{index}}---{{ item }}新闻</button>
    <!-- 遍历对象，最多支持三个参数，第一个是键名，第二个是键值，第三个是下标  -->
    <p v-for="(index,item,key) of info">{{key}}---{{ index }}---{{ item }}</p>
    <!-- 遍历整数，默认从1开始进行遍历，每次递增1，到指定数值结束 -->
    <p v-for="num in 10">{{ num }}</p>
</div>
<script>
    var vm = new Vue({
        el:"#app",
        data:{
            arr:[ '北京','中国','国际','热点'],
            info:{
                name:'小王',
                age:18,
                address:'北京市朝阳区'
            }
        }
    })
    // 原生js中of获取到是的元素内容，in获取到的是元素下标
    // var arr2 = [ '北京','中国','国际','热点']
    // for(item of arr2){
    //     console.log(item)
    // }
</script>

```



# 常见错误

1.vue.js:634 [Vue warn]: Do not mount Vue to <html> or <body> - mount to normal elements instead.

vue的挂载点不能是html、body标签，应该是一个普通的标签

2.[Vue warn]: Property or method "msg" is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property.

vue框架是一个声明式框架，变量或者函数要先声明然后再使用

3.[Vue warn]: Error compiling template:

v-else used on element <a> without corresponding v-if.

v-else和v-else-if必须依存v-if才能使用



# day02

# 一、表单元素双向绑定1.设计模式

### (1)MVC

smalltalk，把用户的输入、输出、处理分开

m model 数据模型层

v view 视图层（html、css、js）

c controller 控制器层

### (2)MVVM

m model 数据模型层

v view 视图层

vm viewmodel 视图模型层

## 2.文本框

```
<input type="text" v-model="msg">

```

数据响应式原理：

<img src="E:/Myweb/stage4/day02/data.png" />

原生JS示例代码：

```javascript
<script>
    let person = {
        wh:"燕人",
        get wh(){
            console.log("获取外号....")
            return "张飞";
        },
        set wh(val){
            console.log("设置外号....",val)
        }
    }
    console.log(person.wh)//读取数据，就会自动触发get方法
    person.wh = "关羽"//设置数据，就会自动地触发set方法
</script>

```

## 3.文本域

textarea

```
<textarea cols="30" rows="10" v-model="content"></textarea>

```

## 4.复选框

checkbox

(1)多选

```vue
<div id="app">
    <div>
        <label>兴趣爱好:</label>
        <input type="checkbox" v-model="hobbys" value="打游戏">打游戏
        <input type="checkbox" v-model="hobbys" value="看电影">看电影
        <input type="checkbox" v-model="hobbys" value="逛吃">逛吃
    </div>
    <div>
        选择的是：{{ hobbys }}
    </div>
    
</div>
<script>
	new Vue({
		el:"#app",
		data:{
			hobbys:[]
		}
	})
</script>

```

复选框的初始数据类型，一定是数组，这样才能够实现多选的情况

多选的情况下，checkbox一定要设置value属性

(2)单选

```vue
<div id="app">
    <div>
    <!-- 是否同意协议：<input type="checkbox" :checked="isagree"> -->
    是否同意协议：<input type="checkbox" v-model="isagree">
    </div>
</div>
<script>
	new Vue({
        el:"#app",
        data:{
            isagree:true
        }
    })
</script>

```

单选的情况下，checkbox不需要设置value属性

## 5.单选框

radio

```vue
<div id="app">
	<div>
        <label>状态：</label>
        <!-- <input type="radio" name="status">正常
<input type="radio" name="status">禁用 -->
        <input type="radio" value="1" v-model="status">正常
        <input type="radio" value="2" v-model="status">禁用
    </div>
    <div>
        选择的是：{{ status }}
    </div>
</div>
<script>
	new Vue({
        el:"#app",
        data:{
            status:1
        }
    })
</script>

```

radio和checkbox（多选）一样，都是要设置value属性，这样在进行数据绑定时，才能够根据指定的数据，控制元素的选中效果。

## 6.下拉菜单

select > option

```vue
<div id="app">
    <div>
        <label>所学专业</label>
        <select v-model="course">
            <option value="">--请选择--</option>
            <option value="1">web前端</option>
            <option value="2">java开发</option>
            <option value="3">ui设计</option>
        </select>
    </div>
    <div>
        选择的是：{{ course }}
    </div>
</div>
<script>
	new Vue({
        el:"#app",
        data:{course:""}
    })
</script>

```

原生html中想让某个选项选中，需要在这个选项中添加selected属性

```
<option selected="selected">web前端</option>

```

在vue中直接给select标签添加v-model双向绑定，就可以给相应的选项设置选中效果

# 二、自定义指令

```
Vue.directive("指令名称",{
	//inserted:function(el)
	inserted(el){
		//el就是使用自定义指令的标签元素
		//js操作。。。
	}
})

```

指令名称不需要添加v-前缀，但是在使用指令的时候需要添加v-前缀

inserted 被绑定元素插入父节点时就会调用该函数

bind 指定绑定到对应的元素后就会调用该函数

示例代码：

```vue
<div id="app">
    <input type="text" v-focus>
</div>
<script>
    Vue.directive("focus",{
        inserted(el){
            //el 就是使用该指令的标签元素
            el.focus();
        }
    })
    new Vue({
        el:"#app"
    })
</script>

```

示例代码2：

```vue
<div id="app">
    <h1 v-color="'red'">{{ msg }}</h1>
    <h1 v-color="'green'">{{ msg }}</h1>
</div>
<script>
    Vue.directive("color",{
        bind:function(el,binding){
            //el 是使用自定义指令的元素
            //binding 是自定义指令绑定的相关数据信息
            el.style.color = binding.value;
        }
    })
    new Vue({
        el:"#app",
        data:{
            msg:'hello 自定义指令'
        }
    })
</script>

```

# 三、修饰符

## 1.事件修饰符

(1).prevent

阻止默认事件

(2).stop

阻止事件冒泡

(3).capture

捕获事件冒泡，影响事件冒泡的顺序

(4).self

事件触发者是元素本身时，对应的事件函数才会执行

(5).once

修饰指定事件、修饰符只执行一次

示例代码：

```vue
<div id="app">
    <!-- 阻止默认事件 -->
    <!-- 修饰符可以连贯起来使用，也就是给一个事件添加多个修饰符 -->
    <button @contextmenu.prevent.once="menu">按钮</button>
    <!-- 阻止事件冒泡 -->
    <div class="outer" @click="outer">
        <div class="inner" @click.stop="inner"></div>
    </div>
    <hr>
    <!-- 捕获事件冒泡 -->
    <div class="outer" @click.capture="outer">
        <div class="inner" @click="inner"></div>
    </div>
    <!-- self -->
    <hr>
    <div class="outer" @click.self="outer">
        <div class="inner" @click.once="inner"></div>
    </div>
</div>
<script>
    new Vue({
        el:"#app",
        methods: {
            menu(){
                console.log('右键被点击了....');
            },
            outer(){
                console.log("outer....")
            },
            inner(){
                console.log("inner....")
            }
        },
    })
</script>

```

## 2.表单元素修饰符

(1).lazy

不再对表单元素进行实时的数据双向绑定，只有遇到change事件时，才会进行数据的双向绑定

(2).number

number修饰符可以保持数据类型为number，如果输入的内容中是以数字开头，非数字结尾，可以把非数字内容进行过滤。

(3).trim

过滤输入内容左右两边的空格

## 3.其他修饰符

(1)鼠标修饰符

.left

.middle

.right

(2)键盘修饰符

keydown、keyup

.esc

.enter

.space

.backspace

.left

.right 

.down

.up 

.delete







# day03

# 一、监听器

侦听器

作用：检测变量值的变化，只要数据变化，就可以触发相应的函数执行一定的操作。

作为vue实例的配置选项，watch

## 1.普通监听

可以检测标量类型数据的变化：字符串、数字（整数、浮点数）、布尔值

当依赖的数据发生变化时，就会触发对应的函数

①写法一

```vue
<script>
	new Vue({
		el:"",
		data:{ipt:''},
		watch:{
			ipt([newVal,oldVal]){
				....
			}
		}
	})
</script>

```

②写法二

```vue
<script>
	new Vue({
		el:"",
		data:{ipt:''},
		watch:{
			ipt:{
                handler([newVal,oldVal]){...}
            }
		}
	})
</script>

```

## 2.深度监听

如果要监听的数据类型是复合类型时，普通的监听方式是无法实现，需要使用第二种写法并添加deep配置选项，来实现监听复合类型数据的变化。

复合类型：对象、数组

```vue
<script>
	new Vue({
		el:"",
		data:{
            info:{ name:'' }
        },
		watch:{
			info:{
                handler:function([newVal,oldVal]){...},
                deep:true//显示的设置为深度监听
            }
		}
	})
</script>

```

# 二、数据变化后页面不更新

解决办法：

(1)$set

```
vue.$set(target,key,value)

```

target是要改变的数据

key是数组的下标

value是要改变的内容

(2)$forceUpdate

强制重新渲染页面

(3)使用数据的相关api方法（push、shift、unshift...）

# 三、计算属性

## 1.基本使用

页面上有频繁需要进行计算得到结果，可以使用计算属性

computed

```vue
<div id="app">
	{{ 要计算的结果变量名 }}
</div>
<script>
	new Vue({
		el:"",
		computed:{
			要计算的结果变量名1(){
				计算逻辑...
				return 计算结果
			},
            要计算的结果变量名N(){
				计算逻辑...
				return 计算结果
			},
		}
	})
</script>

```

## 2.计算属性和监听的区别

相同：依赖的数据发生变化时，对应的函数会自动执行

不同：触发场景不同，监听是在页面渲染完成后，数据发生变化时，才会触发对应的函数

​		计算属性，只要页面中使用了计算属性的结果，或者依赖的数据发生变化时，就会触发对应的函数。

## 3.计算属性与函数的区别

计算属性依赖的数据，不发生变化时，不会重新执行相应的函数，因为计算属性在vue实例上产生了一个缓存。

函数调用几次，就会执行对应的函数几次，在性能上消耗比计算属性大很多。

==计算属性的结果不能直接赋值==

# 四、过滤器

作用：在页面展示数据前，可以通过过滤器对要展示的数据进行二次处理，满足一定的需求后再展示出数据。

## 1.定义

(1)全局定义

```
Vue.filter("过滤器名称",function(形参1){...})

```

(2)局部定义

```javascript
<script>
	new Vue({
		el:"",
		data:{},
		methods:{},
		watch:{},
		computed:{},
		filters:{
			过滤器名称:function(实参1){
				处理逻辑...
				return 处理结果
			}
		}
	})
</script>

```

## 2.使用

在挂载点内，通过管道符“|” 来使用定义好的过滤器。

```
{{ 要展示的变量 | 过滤器名称 }}

```

## 3.过滤器的参数

在过滤器中，第一个参数默认是管道符左边的数据

如果要传递额外的其他参数时，需要像使用函数传参一样，把过滤器名称当成函数名称，然后在后面传递额外的参数。

示例代码：

```vue
<div id="app">
	<p>
        <!-- 调用过滤器后，就会展示一个两位小数的价格 -->
        价格：{{ price | formatPrice }}
    </p>
    <p>
        <!-- 调用过滤器后，就会展示一个一位小数的价格 -->
        价格：{{ price | formatPrice(1) }}
    </p>
</div>
<script>
    new Vue({
        filters:{
            formatPrice:function(price,n=2){
                return '￥' + price.toFixed(n) + '元';
            }
        },
        el:"#app",
        data:{ price:288 }
    });
</script>

```

# 五、生命周期

vue实例从创建、挂载、更新、销毁的一个完整的过程叫做生命周期。

==钩子==函数（在指定的场景下会自动触发的函数）

## 1.页面渲染期

beforeCreate 	vue实例创建之前

created				vue实例创建完成

beforeMount	 vue实例挂载到挂载点之前

mounted			vue实例挂载到挂载点之后

## 2.页面更新期

beforeUpdate 	数据更新之前

updated				数据更新完成

## 3.页面销毁期

beforeDestroy	页面销毁之前

destroyed			页面销毁完成







```vue
<script>
        let app = document.getElementById('app');
        var vm = new Vue({
            el: "#app",
            data: {
                msg: '朝朝暮暮'
            },
            beforeCreate() {
                console.log('vue实例创建之前', 'el:' + this.$el, 'data:' + this.$data, '内容', app);
                //实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性
            },
            created() {
                console.log('vue实例创建完成', 'el:' + this.$el, 'data:' + this.$data, '内容', app);
                //实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板
            },
            beforeMount() {
                console.log('vue实例挂载之前', 'el:' + this.$el, 'data:' + this.$data, '内容', app);
                //此时已经完成了模板的编译，但是还没有挂载到页面中
            },
            mounted() {
                console.log('vue实例挂载完成', 'el:' + this.$el, 'data:' + this.$data, '内容', app);
                //此时，已经将编译好的模板，挂载到了页面指定的容器中显示;    
            },
            beforeUpdate() {
                console.log("数据更新之前", 'el:' + this.$el, 'data:' + this.$data, '内容', app);//状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点(useOldData)
            },
            updated() {
                console.log("数据更新完成", 'el:' + this.$el, 'data:' + this.$data, '内容', app);//实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！
            },
            beforeDestroy() {
                console.log("vue实例销毁之前")//实例销毁之前调用。在这一步，实例仍然完全可用。
            },
            destroyed() {
                console.log("vue实例销毁完成")//实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。
            },
        })

        var btn1 = document.querySelector("#xiaohui")
        btn1.onclick = function () {
            vm.$destroy();
        }
        var btn2 = document.getElementById("guazai");
        btn2.onclick = function () {
            vm.$mount("#app")
        }
    </script>

```

​	







# day04

# 一、过渡动画

使用场景：v-if、v-show、动态组件、组件根节点

## 1.内置类名

```
<transition>
	<要使用过渡动画效果的标签></要使用过渡动画效果的标签>
</transtion>

```

### (1).匿名动画

进入

​	进入开始			v-enter

​	进入进行中		v-enter-active

​	进入结束			v-enter-to

离开

​	离开开始			v-leave

​	离开进行中		v-leave-active

​	离开结束			v-leave-to

示例代码：

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <style>
        .box{
            width: 300px;
            height: 300px;
            background-color: red;
        }
        .v-enter,.v-leave-to{ opacity: 0; }
        .v-enter-active,.v-leave-active{ transition:1.5s linear; }
        .v-enter-to,.v-leave{ opacity: 1; }
    </style>
</head>
<body>
    <div id="app">
        <transition>
            <div class="box" v-if="show"></div>
        </transition>
        <button @click="show=!show">切换</button>
    </div>
    <script>
        new Vue({
            el:"#app",
            data:{
                show:true
            }
        })
    </script>
</body>
</html>

```

### (2)具名动画

页面中有多个标签要设置不同的过渡动画效果时，需要给transition标签设置name属性，设置name属性之后，内置类名的前缀就要改为对应的name属性。

```vue
<style>
	/* 具名过渡动画 */
    .move-enter,.move-leave-to{left:0;}
    .move-enter-active,.move-leave-active{ transition:1.5s linear;background-color: blue; }
     .move-enter-to,.move-leave{ left: 600px; }
    </style>
<transition name="move">
	<div class="box2" v-if="show"></div>
</transition>

```

## 2.animate.css动画库

(1)安装

```
npm i animate.css

```

(2)引入

```
<link rel="stylesheet" href="./node_modules/animate.css/animate.css">

```

(3)使用

需要给transition标签设置两个属性

enter-active-class	进入的动画

leave-active-class   离开的动画

示例代码：

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>过渡动画-动画库</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <link rel="stylesheet" href="./node_modules/animate.css/animate.css">
    <style>
        .box{
            width: 300px;
            height: 300px;
            background-color: red;
        }
    </style>
</head>
<body>
    <div id="app">
        <button @click="show=!show">切换</button>
        <transition 
            enter-active-class="animate__animated animate__bounceInUp"
            leave-active-class="animate__animated animate__bounceOutLeft"
        >
            <div class="box" v-if="show"></div>
        </transition>
        
    </div>
    <script>
        new Vue({
            el:"#app",
            data:{
                show:true
            }
        })
    </script>
</body>
</html>

```

## 二、组件【重点】

## 1.介绍

组件即零件，组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用

组件是==可复用==的 ==Vue 实例==

因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。

## 2.注册

### (1)局部注册

```
new Vue({
	components:{
		组件名称1:{
			template:"组件模板内容"
		},
		组件名称N:{
			template:"组件模板内容"
		}
	}
})

```

### (2)全局注册

```
Vue.component("组件名称1",{ template:"组件模板内容" })
Vue.component("组件名称N",{ template:"组件模板内容" })

```

## 3.使用

在vue的挂载点内，以标签的方式来使用组件

在vue的挂载点内使用组件后，组件名称的所在位置会被组件的template内容进行替换。

示例代码：

```vue
<div id="app">
    <!-- 使用组件 -->
    <mycom></mycom>
    <mycom></mycom>
    <mycom></mycom>
</div>
<script>
    new Vue({
        el:"#app",
        components:{
            mycom:{
                // 组件的template中只能有一个根标签
                template:"<div><h1>这是一个自定义组件</h1><h2>标题2</h2></div>"
            }
        }
    })
</script>

```

## 4.注册组件注意事项

(1)组件名称不能是系统内置的标签名

(2)组件名称不能是系统内置的大写的标签名

(3)如果组件名称中包含了大写字母，在使用要把大写字母转换成-小写字母

(4)template内容中只能有一个根标签

## 5.template的使用

### (1)vue实例的template选项

组件中可以通过template属性来设置该组件的模板内容

vue实例上也可以设置一个template属性，用来把指定的template对应的内容或者组件，替换到vue实例的挂载点内。

示例代码：

```vue
<script>
	new Vue({
        el:"#con",
        // template:"<h2>vue实例的template属性</h2>"
        template:"<my-div />",
        components:{
            myDiv:{
                template:"<h1>自定义组件</h1>"
            }
        }
    });
</script>

```

### (2)template标签

如果组件中的模板内容比较多时，使用字符串的方式编写html代码会很麻烦，且没有任何语法提示，如果代码编写不够熟练，非常容易出现错误。

vue中给提供了一个template标签，用来存放组件的模板内容

示例代码：

```vue
<div id="app">
    <mycom></mycom>
</div>
<template id="mycom">
	<div>
    	<h1>自定义组件</h1>
    </div>
</template>
<script>
    new Vue({
        el:"#app",
        components:{
            mycom:{
                // 让组件的template属性和template标签关联起来
                template:"#mycom"
            }
        }
    })
</script>

```

## 6.组件的key属性

组件遍历循环时，需要给组件添加一个唯一的标识，能够加快页面的渲染速度

## 7.组件中的data应该是一个函数

由于对象是引用类型，所以在data中
；；以对象的方式定义初始数据，然后在组件中使用数据并复用这个组件时，会产生数据上的冲突（也就是一个数据改变了之后，其他的也跟着进行变化）

所以，在组件中定义初始数据，需要以函数的方式返回一个新的对象来定义数据，这样每复用一次组件，就会调用一次data的函数并返回一个新的数据存储空间，这样组件与组件之间的数据就不会互相影响了。

实例代码：

```vue
<div id="app">
    <v-box></v-box>
    <v-box></v-box>
    <v-box></v-box>
</div>
<template id="box">
<div class="box">
    <p>数量：{{ num }}</p>
    <button @click="num++">增加数量</button>
    </div>
</template>
<script>
    new Vue({
        el:"#app",
        components:{
            vBox:{
                template:"#box",
                data:function(){
                    return{
                        num:100
                    }
                }
            }
        }
    })
</script>

```

注意：在组件中，不能直接使用vue根实例上的data数据，因为组件也是一个vue实例，实例与实例之间的数据是不共享的。

# 三、vue-cli脚手架

最新版本：4.X

稳定版本：2.9.6

## 1.安装

node环境

(1)webpack

```
npm i webpack -g

```

(2)vue-cli

```
npm i vue-cli -g

```

## 2.初始化项目

进入到一个指定的目录中，然后进入命令行

```
vue init webpack mydemo

```

安装过程：

```
Project name (mydemo) 	项目名称，如果不需要修改直接回车
Project description (A Vue.js project) 项目描述，如果不需要修改直接回车
Author (fan <fanmingjian@offcn.com>) 项目作者，如果不需要修改直接回车
Vue build (Use arrow keys) vue构建方式，选择默认的热编译
> Runtime + Compiler: recommended for most users
  Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specific HTML) are ONLY allowed in .vue files - re
nder functions are required elsewhere
Install vue-router? (Y/n) 是否安装vue路由，输入n
Use ESLint to lint your code? (Y/n) 是否安装eslint代码验证工具，输入n
Set up unit tests (Y/n) 是否创建单元测试，输入n
Setup e2e tests with Nightwatch? (Y/n) 是否创建端对端测试，输入n
Should we run `npm install` for you after the project has been created? (recommended) (Use arrow keys) 选择依赖安装方式，选择npm
> Yes, use NPM
  Yes, use Yarn
  No, I will handle that myself


```

## 3.运行项目

在命令行中，进入项目根目录，执行如下命令：

```
npm run dev


```

localhost:8080

## 4.目录结构

```
mydemo
	build		项目打包主程序目录
	config		项目配置文件目录
	node_modules 项目依赖目录
	src			项目源码目录
		assets	项目静态资源目录（参与打包）
		components 项目组件目录
		App.vue	项目根组件
		main.js	项目启动文件
	static		项目静态资源目录
	index.html	项目首页
	package.json项目依赖配置文件


```

项目运行流程：

index.html

/src/main.js

/src/App.vue

## 5.vue组件构成

在脚手架中，组件以单独的.vue后缀的文件存在，组件由三部分组成：

template模板，只有一个，所以不需要设置id属性

script 组件逻辑代码【非必须】

style 组件样式代码【非必须】

所有的组件都要先从App.vue开始，它是脚手架的根组件，在App.vue要引用其他组件的话需要使用import关键词

示例代码：

创建一个Home组件

/src/components/Home.vue

```vue
<template>
    <div>
        <h1>home组件</h1>
        <v-top></v-top>
    </div>
</template>
<script>
import vTop from './Top'
export default {
    components:{ vTop}
}
</script>


```

/src/App.vue

```vue
<script>
// 引入Home组件
import Home from './components/Home'
export default {
	components: {
		Home
	}
}
</script>
<template>
	<div id="app">
		<Home />
	</div>
</template>

<style>
/* 全局样式 */
h1 { color: red;}
</style>


```



# 常见错误

1.[Vue warn]: Unknown custom element: <mycom> - did you register the component correctly? For recursive components, make sure to provide the "name" option.

组件没有正确的注册就使用了

2.vue.js:634 [Vue warn]: Do not use built-in or reserved HTML elements as component id: div

不使用系统内置标签作为组件名称



3.[Vue warn]: The "data" option should be a function that returns a per-instance value in component definitions.





# day05

# 一、组件通信【重点】

场景：由于组件与组件数据不共享，当需要复用组件并让组件中的内容不一样时，可以使用组件通信来实现。

## 1.父子组件

自定义属性和props

第一步：先创建两个组件，一个父组件parent.vue，一个子组件child.vue

在App.vue中引入父组件，并使用它

```vue
<script>
import vParent from './components/parent'
export default {
	components: {
        vParent
    }
}
</script>
<template>
	<div class="page">
        <v-parent></v-parent>
	</div>
</template>

```

第二步：在父组件中引入子组件，构建父子组件的关系，并通过自定义属性传递数据

/src/components/parent.vue

```vue
<template>
    <div>
        <h1>父组件</h1>
        <!-- 在父组件使用子组件时，通过自定义属性来传递数据 -->
        <v-child v-for="(item,index) of newsarr" :key="index"
            :newstitle="item"
        ></v-child>
    </div>
</template>
<script>
import vChild from './child'
export default {
    components:{ vChild  
    data(){
        return{
            newsarr:['国内','北京','国际','娱乐']
        }
    }
}
</script>

```

第三步：在子组件child.vue中通过props选项来接收父组件传递数据，并在子组件中使用这些数据

/src/components/child.vue

```vue
<template>
    <div class="box">
        <h1>{{ newstitle }}新闻</h1>
    </div>
</template>
<script>
export default {
    // 在子组件中通过props来接收父组件传递的数据
    // 子组件接收到数据后，就可以直接在子组件的模板中使用该数据了
    props:['newstitle']
}
</script>
<style>
    .box{
        border:1px solid #000;
        margin:20px;
        padding:20px;
    }
</style>

```

### props验证

子组件可以对父组件传递的数据进行一些验证：数据类型、默认值、自定义验证。。。

#### (1)验证数据类型

```js
<script>
export default {
    props:{
        // 验证数据类型，可以验证常见的数据类型：
        //字符串String 数字Number 布尔值 Boolean 对象 Object 函数 Function等
        newstitle:String
    }
}
</script>

```

验证多个数据类型

如果要接收的变量是多个数据类型，则需要这样去进行验证

```js
<script>
export default {
    props:{
        newstitle:[String,Number]//此时父组件传递的数据既可以是字符串，也可以是数字
    }
}
</script>

```

#### (2)验证必填

```js
<script>
export default {
    props:{
        viewnum:{
        	required:true,
            type:Number//验证必填的同时还可以验证数据类型
        }
    }
}
</script>

```

如果子组件中有一个父组件必须传递的数据，可以通过required来进行验证。

#### (3)默认值

```vue
<script>
export default {
    props:{
        viewnum:{
        	required:true,
            type:Number//验证必填的同时还可以验证数据类型
        },
        first:{
            // default:"什么也没有"
            //如果数据类型是对象或者数组时，默认值是一个函数，返回对应的数据格式
            default:function(){
                return{
                    title:'什么也么有'
                }
            }
        }
    }
}
</script>

```

#### (4)自定义验证规则

```vue
<script>
export default {
    props:{
        viewnum:{
        	required:true,
            type:Number,//验证必填的同时还可以验证数据类型
            validator:function(val){
                //自定义验证规则，只要返回值为false就会出现警告
                return val > 1 && val <= 999;
            }
        }
    }
}
</script>

```

props验证给出只是警告，不影响程序的运行。

## 2.子父组件

自定义事件、$emit

第一步：在父组件使用子组件的时候，传递一个自定义函数，并在父组件中定义好对应的函数操作

```vue
<v-child v-for="(item,index) of newsarr" :key="index"
    :newstitle="item.title" :num="item.num"
    :newsidx="index"
    @addbychild="addnum"
></v-child>
<script>
export default {
    components:{ vChild }, 
    methods:{
        addnum(n){
            this.newsarr[n].num++;
        }
    },
    data(){
        return{...}
    }
</srcipt>
    

```

第二步：在子组件中通过vue实例上的$emit方法，来触发父组件传递的事件函数                         

```vue
<template>
    <div class="box">
        <span>{{ newstitle }}</span>
        <span>访问量：{{ num }}</span>
        <button @click="add">访问</button>
    </div>
</template>

<script>
export default {
    props:['newstitle','num','newsidx',"arr"],
    methods:{
        add(){
            //触发父组件传递的事件函数，并传递参数
            this.$emit("addbychild",this.newsidx)
        }
    }
}
</script>

```

## 3.非父子组件

公用的容器（eventbus）、$emit、$on

第一步，创建一个公用的容器

/src/main.js实例化vue之前

```
Vue.prototype.$ev = new Vue();

```

第二步：在数据发送的组件中，通过公用容器进行数据发送

```
this.$ev.$emit("事件名称","要传递的数据")

```

第三步：在数据接收的组件的挂载完成生命周期中实现数据的接收

```
mounted() {
    //通过容器，一直监听数据，只要有数据的发送，就可以收到数据
    this.$ev.$on("时间名称",(str)=>{
    	...
    })
}

```

# 二、组件进阶

## 1.is属性

改变html标签默认结构约束

动态组件

示例代码：

menu.vue

```vue
看 plate>
    <div class="menu">
        <a @click="tab('setting')">系统设置</a>
        <a @click="tab('student')">学生管理</a>
        <a @click="tab('course')">课程管理</a>
    </div>
</template>

<script>
export default {
    methods:{
        tab(tag){
            console.log(tag,'发送')
            this.$ev.$emit("changeTag",tag)
        }
    }
}
</script>

<style>
    .menu{
        text-align: center;
    }
    .menu a{
        display: block;
        color:#fff;
        font-size: 20px;
        margin:10px;
        cursor: pointer;
    }
</style>

```

main.vue

```vue
<template>
    <div class="main">
        <v-menu></v-menu>
        <div class="right">
            <!-- 动态组件 -->
            <div :is="tagname"></div>
        </div>
    </div>
</template>
<script>
import vMenu from './menu'
import setting from './setting'
import student from './student'
import course from './course'
export default {
    components:{
        vMenu,setting,student,course
    },
    mounted() {
        this.$ev.$on("changeTag",(t)=>{
            console.log(t,'接收')
            this.tagname = t;
        })
    },
    data(){
        return{
            msg:'hello',
            tagname:'setting'
        }
    }
}
</script>
<style>
    .main{
        flex:1;
        display: flex;
    }
    .menu{
        width:120px;
        background-color: #000;
    }
    .right{
        flex:1;
    }
</style>

```



## 2.ref

vue中提供了一个ref属性，可以给标签添加ref属性，来实现原生JS的一些操作或者父子组件通信的效果。

(1)字符串

```
<h1 ref="myh1">系统设置页面</h1>

```

此时在$refs中就会增加了一个myh1的内容，它的值就是DOM元素。

(2)数组

```
<ul>
	<li ref="lis" v-for="item of numarr" :key="item">{{ item }}</li>
</ul>

```

如果ref应该在一个遍历循环上，则会在$refs中增加一个数组，数组的每个元素都是一个DOM元素

(3)组件【常用】

给自定义组件添加ref属性后，可以利用DOM操作的方式，来给组件进行数据的传递

```vue
<template>
	<div>
		<v-item ref="myitem"></v-item>
	</div>
</template>
<script>
import vItem from './item'
export default {
    components:{ vItem },
    mounted(){
        //直接在父组件中通过ref来给子组件进行数据的传递
        this.$refs.myitem.msg = '系统设置-数据'
    }
}
</script>

```

## 3.jquery

如果有一些页面效果，不知道用vue如何实现，但是知道用jquery去实现，那么在vue中可以用jquery来进行操作。

### (1)安装

```
npm i jquery

```

### (2)使用

```vue
<script>
//引入jquery
import $ from 'jquery'
export default {
    methods:{
        toggle(){
            this.jQuery(".box").slideUp(2000)
        }
    }
</script>
<template>
	<div>
        <button @click="toggle">toggle</button>
        <div class="box"></div>
    </div>
</template>
<style>
    .box{
        width: 200px;
        height: 200px;
        background-color: #f00;
    }
</style>

```





# day06

# 一、组件进阶

## 4.插槽

在父组件中复用子组件时，子组件中展示内容/结构由父组件来告知。

slot

### (1)匿名插槽

第一步：在子组件中添加一个slot标签，用来展示父组件传递的内容（可以是数据也可以是html结构）

```vue
<template>
<div>
    <!-- 插槽 -->
    <slot></slot>
    <slot></slot>
</div>
</template>
```

只要在子组件中设置了slot标签，就可以在父组件中来分发内容，并且将分发的内容展示在插槽的位置上。

第二步：在父组件中使用子组件时，在子组件内部传递数据或者html结构

```vue
<script>
import index from './components/index'
export default {
	components:{ index }
}
</script>
<template>
	<div class="page">
		<index>
			<!-- 
				给子组件追加额外内容 
				此处内容可以是html代码
			-->
			<h1>这是首页</h1>
			<p>文本内容</p>
		</index>
	</div>
</template>
```

### (2)具名插槽

在子组件中添加slot标签给它设置name属性，用来区分不同的插槽，把父组件分发的不同内容展示在不同的插槽位置上。

```
<slot name="top"></slot>
<slot name="bottom"></slot>
```

在父组件使用子组件时，给追加的内容添加上slot属性，就可以把指定的内容放到指定的插槽上。

```
<index>
    <h1 slot="top">这是首页</h1>
    <p slot="bottom">文本内容</p>
</index>
```

### (3)作用域插槽

希望父组件控制插槽展示的内容，子组件提供数据

当子组件做循环或者它的某一部分内容由父组件来分发，这种场景要用到作用域插槽。

子组件遍历数据

```vue
<template>
    <div>
        <p>child组件</p>
        <ul>
            <slot name="list" v-for="item of arr" :item="item"></slot>
        </ul>
    </div>
</template>
<script>
export default {
    data(){
        return{
            arr:[ 'web前端','ui设计','java开发']
        }
    }
}
</script>
```

父组件分发子组件中要展示的html结构

```vue
<child>
    <!-- 作用域插槽 -->
    <template v-slot:list="props">
    	<li>{{ props.item }}</li>
    </template>
</child>
```

## 5.scoped

给组件的style标签添加scoped属性，可以实现让组件的样式只在当前组件内起作用，可以解决样式污染问题。

```
<style scoped></style>
```

# 二、网络请求

axios

## 1.安装

```
npm i axios
```

## 2.引入

```
import axios from 'axios'


```

## 3.使用

### (1)get请求

```
axios.get("请求地址").then(形参=>{
	...
})


```

### (2)代理转发配置

localhost:8080/关键词/链接地址

反向代理：

后端编写代码允许跨域

Apache/Nginx web服务器软件进行代理转发

webpack配置代理

在confing/index.js文件中修改proxyTable选项（代理映射表）

```javascript
proxyTable: {
    // /api是当前vue脚手架链接地址中出现哪个关键词时才进行代理的转发
    '/api':{
        target:'http://suggestion.baidu.com',//目标域名地址（只写域名）
            changeOrigin:true,//允许跨域
                pathRewrite:{
                    //路径重写规则（最终请求的链接地址中没有关键词时才需要进行配置）
                    '^/api':''
                }
    }
}


```

# 三、swiper轮播图插件

## 1.安装

```
npm i vue-awssome-swiper --save


```

## 2.引入

在/src/main.js中全局引入

```
import VueAwesomeSwiper from 'vue-awesome-swiper'
import 'swiper/swiper-bundle.css'


```

css文件一定要引入，否则没有样式效果

在需要使用swiper插件的页面中引入

```javascript
<script>
    import http from "axios";
    import { Swiper, SwiperSlide, directive } from 'vue-awesome-swiper'
    import Swiper2, { Navigation, Pagination, Autoplay } from "swiper"; 
    Swiper2.use([Autoplay, Navigation, Pagination]);
</script>


```

## 3.使用

示例代码：

```vue
<template>
  <div>
    <swiper 
      ref="mySwiper" 
      :options="swiperOptions"
    >
      <swiper-slide v-for="(banneritem,index) of bannerArr" :key="index">
        <img :src="banneritem.imageUrl"/>
      </swiper-slide>
      <div class="swiper-pagination" slot="pagination"></div>
      <div class="swiper-button-prev" slot="button-prev"></div>
      <div class="swiper-button-next" slot="button-next"></div>
    </swiper>
  </div>
</template>
<script>
import http from "axios";
import { Swiper, SwiperSlide, directive } from 'vue-awesome-swiper'
import Swiper2, { Navigation, Pagination, Autoplay } from "swiper"; 
Swiper2.use([Autoplay, Navigation, Pagination]);
export default {
  data(){
    return{
      bannerArr:[],
      swiperOptions: {
        autoplay:true,
        pagination: {
          el: '.swiper-pagination',
          clickable: true
        },
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev"
        }
      }
    }
  },
  components: {
    Swiper,
    SwiperSlide
  },
  directives: {
    swiper: directive
  },
  mounted() {
    //发起网络请求，获取轮播图信息
    http.get("/api/banner").then(res => {
      this.bannerArr = res.data.banners;
    });
  }
};
</script>

<style>
.swiper-container{
  width:400px;
  height:300px;
}
.swiper-container img{
  width:100%;height:100%;
}
</style>


```

# 四、路由【重点】

## 1.介绍

Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：

嵌套的路由/视图表
模块化的、基于组件的路由配置
路由参数、查询、通配符
基于 Vue.js 过渡系统的视图过渡效果
细粒度的导航控制
带有自动激活的 CSS class 的链接
HTML5 历史模式或 hash 模式，在 IE9 中自动降级
自定义的滚动条行为

SPA single page application

MPA multi page application【传统】

## 2.安装

### (1)初始化项目选择安装路由

### (2)手动安装

```
npm i vue-router --save


```

## 3.基本使用

(1)引入

/src/main.js

```
import VueRouter from 'vue-router';
Vue.use(VueRouter)


```

此时，vue实例上会多两个变量，一个$route，一个$router，但是它们的值是undefined

(2)配置路由映射表

```
import home from './components/home'
import music from './components/music'
const router = new VueRouter({
    // 路由映射配置表
    routes:[
        { path:'/home',component:home },
        { path:'/music',component:music}
    ]
})


```

(3)把vuerouter实例，挂在到vue实例上

```
new Vue({
    el: '#app',
    // router:router,
    router,
    components: { App },
    template: '<App/>'
})


```

把vuerouter实例挂到vue上之后，浏览器地址中会自动增加一个#

#号后面的内容是路由规则，当路由映射表中的path属性匹配成功之后，对应的页面内容就可以展示

(4)设置路由出口

App.vue

```
<router-view />


```

## 4.路由导航

### (1)内置标签

router-link 会在页面上生成一个a标签，并可以设置导航按钮的激活状态

to 必须要设置的属性，给导航设置目标路由地址

active-class 可选属性，给导航设置激活状态

### (2)编程式导航

$router是vuerouter的实例，它的原型上提供一系列的方法供我们使用

①push

```
$router.push(目标路由地址)


```

②replace

```
$router.replace(目标路由地址)


```

push方法会在进行页面跳转之前，记录跳转之前访问的路由地址

replace方法用指定的路由地址替换当前访问的路由地址

③go

回退到上一次访问的页面，一般给一个-1的实参

```
$router.go(-1)


```

## 5.路由重定向

redirect

```vue
export default new Router({
  routes: [
    { path:'/recommend',component:recommend },
    { path:'/songlist',component:songlist },
    { path:'/search',component:search },
    { path:'*',redirect: '/recommend'}
    // { path:'*',component: recommend}
  ]
})


```

## 6.路由嵌套

如果在某个页面中还要展示不同的子级页面，那么需要用到路由嵌套

第一步：定义子级页面

第二步：定义子级页面对应的路由规则

```javascript
import Vue from 'vue'
import Router from 'vue-router'
Vue.use(Router)
import index from '../components/index'
import play from '../components/play'
import recommend from '@/components/recommend'
import songlist from '../components/songlist'
import search from '../components/search'
import recomlist from '../components/recomlist'
export default new Router({
  routes: [
    {
      path:'/index',component:index,
      children:[
        { path:'recommend',component:recommend },
        { path:'songlist',component:songlist },
        { path:'search',component:search },
        { path:'',redirect:'recommend' }
      ]
    },
    { path:'/play',component:play },
    { path:'/recomlist/:id',component:recomlist },
    { path:'*',redirect: '/index'}
  ]
})



```

在首页中再添加一个router-view标签，用来展示子级页面内容。

```vue
<template>
  <div>
    <!-- 路由导航 -->
    <div class="nav">
        <!-- router-link必须要设置to属性，类似a标签的href属性 -->
        <router-link to="/index/recommend" active-class="active">推荐音乐</router-link>
        <router-link to="/index/songlist" active-class="active">热歌榜</router-link>
        <router-link to="/index/search" active-class="active">搜索</router-link>
    </div>
    <!-- 展示二级路由对应的页面组件 -->
    <router-view></router-view>
  </div>
</template>


```

## 7.路由传参

### (1)动态路由

第一步：定义一个动态路由规则，让不同参数的路由地址指向到同一个页面组件

/src/router/index.js

```
{ path:'/recomlist/:id',component:recomlist }


```

$route是当前路由地址的详细信息

$router是vuerouter的实例，包含内置属性和方法（页面跳转等）

第二步：获取动态路由的参数

```
this.$route.params.动态路由参数名称


```

# 作业：网易云音乐案例

接口地址：

1.推荐音乐页面

(1)轮播图

/banner

(2)推荐歌单

/personalized

(3)最新音乐

/personalized/newsong

2.歌单详情页面

/playlist/detail?id=歌单编号

3.热歌榜

top/list?id=3778678

4.歌曲详情页面

/song/detail?ids=1481164987

5.搜索页面

(1)热搜词

/search/hot

(2)搜索

/search/?keywords=关键词







# day07

## 一、axios进阶

## 1.批量请求

当一个页面中需要发起多个网络请求时，可以使用批量请求来实现

第一步：先定义好网络请求的相关函数，有几个网络请求就定义几个函数，每个函数都返回请求的结果

```
getBanner(){
	return this.axios.get('/api/banner');
},
getPersonalized(){
	return this.axios.get('/api/personalized?limit=6')
},
getNewSong(){
	return this.axios.get('/api/personalized/newsong')
}

```

第二步：在页面挂载完成时使用all方法来批量发起网络请求

```
this.axios.all([this.getBanner(),this.getPersonalized(),this.getNewSong()]).then(
    this.axios.spread((bannerRes,personalizeRes,newsongRes)=>{
        this.bannerArr = bannerRes.data.banners;
        this.songListArr = personalizeRes.data.result;
        this.newSongArr = newsongRes.data.result;
	})
)

```



## 二、路由进阶

## 1.路由传参

### (1)动态路由

### (2)查询参数

如果可以接收的参数==数量不固定==时，使用动态路由就不合适了，需要使用查询参数方式。

第一步：定义一个固定链接的路由规则

```
// { path:'/playlist/:id',component:playlist },
{ path:'/playlist',component:playlist },

```

第二步：在列表页进行页面跳转时，传递参数时不使用动态路由的方式传递参数

```
playlist(obj){
//   this.$router.push("/playlist/"+id)
    this.$router.push({
        path:'/playlist',
        query:{id:obj.id,name:obj.name}
    })
},

```

使用查询参数的方式，传递的参数会自动以“?参数名=参数值&参数名=参数值”的方式展示在浏览器地址当中，第一个参数是?开头，其他参数均是&开头。

## 2.路由命名

路由规则中可以设置一个可选参数：name

它的作用是给当前路由规则设置一个重复的名称，在进行路由跳转并传递参数时，可以非常方便的实现。

第一步：定义路由规则时设置name选项

```
{ 
    path: "/playlist/:id", 
    component: playlist,
    name:'gedan'
}

```

第二步：在进行页面跳转时，使用name属性

```
playlist(id){
    //   this.$router.push("/playlist/" +id)
    this.$router.push({
        name:'gedan',
        params:{id}
    })
}

```

## 3.路由别名

alias

```
{ path: "recommend", component: recommend,alias:'tuijian' }

```

添加好别名后，原来的路由规则和别名的路由规则都可以正常访问。

## 4.路由模式

在路由配置文件中，和routes选项平级的一个项目

mode:

​	hash 哈希模式，默认

​	history 

hash模式会在浏览器地址中添加一个#，#号后面默认会当成路由规则进行解析，在路由跳转时，不会重新发起http请求

history模式在浏览器地址中没有#号，利用了html5的history.pushState来完成路由跳转，打包之后的项目部署上线后，一定要配合后端（Apache、Nginx等）web服务器进行代理的转发配置，否则会出现404的情况。

## 5.路由守卫【重点】

路由守卫的作用是对路由规则访问之前进行一定的验证，从而实现拦截的效果

大多数路由守卫钩子函数都有三个参数，分别是：

to 目标路由规则信息

from 来源路由规则信息

next 函数，用来执行或者改变路由规则

```
next()//执行默认路由规则
next('/index/recommend')//执行指定的路由规则
next(false);//中止默认的路由规则

```

根据作用范围不同，分成以下几种方式的路由守卫：

### (1)路由独享守卫

只有某一个路由规则才起作用的守卫

/src/router/index.js

```
{ 
    path: "/play/:id", 
    component: play,
    beforeEnter(to,from,next){
        next()//执行默认路由规则
        // next('/index/recommend')//执行指定的路由规则
        // next(false);//中止默认的路由规则
    }
}

```

此时，只会在访问http://localhost/play/xxxx这一个路由时，钩子函数才会触发

### (2)组件守卫

①beforeRouteEnter

路由规则访问到某一个页面组件之前，会自动触发beforeRouteEnter钩子函数

```vue
<script>
export default {
	beforeRouteEnter(to,from,next){
        //验证操作
        next();
    }
}
</script>

```

②beforeRouteLeave

要从某一个路由规则地址，跳转到另外一个路由规则时，这个钩子函数会自动触发

```vue
<script>
export default {
	beforeRouteLeave(to,from,next){
        var flag = window.confirm("确定要离开此页面吗？")
        if(flag){
            next();
        }
    }
}
</script>

```

③beforeRouteUpdate

动态路由参数变化时自动触发

如果路由模式是history时，此钩子函数失效

```vue
<script>
export default {
	beforeRouteUpdate(to,from,next){
		//验证操作
		next();
    }
}
</script>

```

### (3)全局守卫

/src/router/index.js

```
const router = new Router({...})
全局守卫代码....
export default router;

```

①beforeEach	全局前置守卫

在项目中==所有的==路由地址访问之前，会自动触发

②afterEach	全局后置守卫

它只有两个参数，分别是to和from，没有next

在项目中==所有的==路由地址访问之后，会自动触发，它只有两个参数（不能实现拦截操作）

```
//全局前置守卫
router.beforeEach((to,from,next)=>{
	//验证操作
    next();
});
//全局后置守卫
router.afterEach((to,from)=>{
    console.log(to,'to......')
    console.log(from,'from......')
});
export default router;

```

## 6.路由懒加载

```
{
    path:'/login',
    // component:login
    component:()=>import('../components/login')
}

```



# 三、项目打包

```
npm run build


```

项目打包完成后，会在项目根目录下生成一个dist文件夹







# day08

# 一、状态管理-vuex【重点】

组件通信：

​	父子组件、子父组件、非父子组件

​	ref

​	localStorage、sessionStorage

​	vuex

## 1.介绍

Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用==集中式==存储管理应用的所有组件的状态，并以相应的规则保证状态以一种==可预测==的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 [devtools extension](https://github.com/vuejs/vue-devtools)，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。

## 2.安装

```
npm i vuex

```

## 3.引入

```
import Vuex from 'vuex'
Vue.use(Vuex)

```

## 4.基本使用

核心概念：

### (1)state

Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。

类似于组件中的data

/src/main.js

```javascript
import Vuex from 'vuex'
Vue.use(Vuex)
//初始化仓库
const store = new Vuex.Store({
    //初始数据
    state: {
        name: 'vuex name'
    }
})
new Vue({
    el: '#app',
    router,
    components: { App },
    template: '<App/>',
    //store: store 
    store
})

```

在任意页面组件中就可以直接通过$store.state来获取仓库中的数据

```
<p>仓库中的name为：{{ $store.state.name }}</p>

```

助手函数

mapState，从把仓库中的所有数据全部获取到，并根据需要在页面组件中使用指定的数据

```vue
<template>
	<div>
    	<p>仓库中的newage为:{{ age }}</p>
    </div>
</template>
<script>
import { mapState } from 'vuex'
export default {
    //从仓库中获取到数据，并存放到当前页面的计算属性中
    //变量名和仓库中的一致时的写法
    computed:{
        ...mapState(['name','age'])
    },
    //变量名和仓库中的不一致时的写法
    // computed:mapState({
    //     username:state=>state.name
    // })
}
</script>

```

### (2)getters

根据state中已有的数据，派生出新的数据，类似于组件中的computed

第一步：在仓库中定义好getter规则

```javascript
const store = new Vuex.Store({
    //初始数据
    state: {
        uname: 'vuex name',
        age:18
    },
    //计算属性
    getters:{
        newage(state){
            return state.age + 5;
        }
    }
})

```

第二步：在页面组件中使用getters中的数据

```
<p>仓库中的newage为：{{ $store.getters.newage }}</p>

```

注意：不要从state里获取数据，vuex的计算属性并没有把派生出的数据放到state中。

助手函数

```javascript
import { mapState,mapGetters } from 'vuex'
computed:{
    ...mapState(['uname','age']),
    ...mapGetters(['newage'])//从所有的getters获取指定的计算属性结果
}

```

### (3)mutations

更改 Vuex 的 store 中的状态的==唯一方法==是提交 mutation。

第一步：先在仓库中定义好改变state的方法

```javascript
const store = new Vuex.Store({
    ...
    //修改state的事件函数
    mutations:{
        changeAge(state){
            state.age+=2;
        },
        changeName(state,data){
            state.uname = data;
        }
    }
})

```

第二步：在页面组件中使用定义好的修改state的方法

这样在页面组件中就不用再定义修改数据的方法了，能够实现数据的集中式可预测性变化

```
<button @click="$store.commit('changeAge')">改变仓库中的age</button>
<!-- 传递额外参数 -->
<button @click="$store.commit('changeName','home name')">改变仓库中的name</button>

```

助手函数

如果改变state的函数有很多，而某一个页面组件只需要使用其中的一部分时，可以在当前页面组件中使用助手函数把对应的mutations方法引出来

```js
<template>
	<div>
    	<p>仓库中的newage为:{{ age }}</p>
        <button @click="changeAge">改变age</button>
    </div>
</template>
<script>
import { mapState,mapGetters,mapMutations } from 'vuex'
export default {
    methods:{
        ...mapMutations(['changeAge'])
    }
}
</script>

```

使用mapMutations助手函数后，就可以在页面中像使用自定义函数的方式来使用仓库中定义好的mutations了。

mutations只能执行同步操作

### (4)actions

Action 类似于 mutation，不同在于：

Action 提交的是 mutation，而不是直接变更状态。
Action 可以包含任意异步操作。

第一步：在仓库中定义好actions

```
//初始化仓库
const store = new Vuex.Store({
    ...
    //定义可以执行异步操作的action
    actions:{
        // context 上下文
        CHANGEAGE(context){
            // console.log(context)
            setTimeout(function(){
                context.commit("changeAge")
            },3000);
        }
    }
})

```

第二步：在页面组件中通过dispatch来触发actions

```
<button @click="$store.dispatch('CHANGEAGE')">改变仓库中的age-action方式</button>
传递参数
<button @click="$store.dispatch('CHANGEAGE',10)">改变仓库中的age-action方式</button>

```

助手函数

```vue
<template>
    <div>
        <h1>child组件</h1>
        <button @click="changeAge">改变age</button>
        <button @click="CHANGEAGE">改变age-action</button>
    </div>
</template>
<script>
import { mapMutations,mapActions } from 'vuex'
export default {
    methods:{
        ...mapMutations(['changeAge']),
        ...mapActions(['CHANGEAGE'])
    }
</script>

```

此时，在当前页面组件中就可以直接调用CHANGEAGE这个action，来执行一些异步的操作。

### (5)modules

由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。

为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter

第一步：创建一个shop模块，并在其中定义好state和mutations等

/src/store/shop/index.js

```js
export default{
    state:{ num:200 },
    mutations:{
        changeNum(state){
            state.num+=1;
        }
    }
}

```

第二步：在根模块中设置一个子模块

/src/store/index.js

```js
export default new Vuex.Store({
    ...
    modules:{ shop }
})


```

第三步：在页面中调用根模块和shop模块的数据及改变数据的方法

```vue
<p>仓库中根模块的num为：{{ $store.state.num }}</p>
<p>仓库中shop模块的num为：{{ $store.state.shop.num }}</p>
<button @click="$store.commit('changeNum')">修改num</button>


```

此时会发现点击按钮后根模块和shop模块的num变量都发生了变化

为了解决这个问题，可以给模块启用命名空间、

/src/store/shop/index.js

```
export default{
    namespaced:true,//启用命名空间
    state:{
        num:200
    },
    mutations:{
        changeNum(state){
            state.num+=1;
        }
    }
}


```

namespaced:true 表示启用命名空间

然后在页面中调用shop模块中的mutation

```
<button @click="$store.commit('shop/changeNum')">修改shop模块的num</button>


```

# 二、stylus样式预处理器

## 1.介绍

- 冒号可有可无
- 分号可有可无
- 逗号可有可无
- 括号可有可无
- 变量
- 插值（Interpolation）
- 混合（Mixin）
- 数学计算
- 强制类型转换
- 动态引入
- 条件表达式
- 迭代
- 嵌套选择器
- 父级引用
- Variable function calls
- 词法作用域
- 内置函数（超过 60 个）
- 语法内函数（In-language functions）
- 压缩可选
- 图像内联可选
- Stylus 可执行程序
- 健壮的错误报告
- 单行和多行注释
- CSS 字面量
- 字符转义
- TextMate 捆绑

## 2.安装

```
npm i stylus-loader@3.0.2 stylus --save


```

## 3.引入

```
<style lang="stylus">


```

## 4.基本使用

(1)基础语法

```
<style lang="stylus">
    .page
        width 100vw
        height 100vh
        display flex
        flex-direction column
        .top
            height 50px
            background-color skyblue
        .middle
            flex 1
            display flex
            .menu
                width 100px
                background-color:#000
            .right
                flex 1
                background-color #fff
            
</style>


```

(2)变量的使用

可以在预先定义好一些项目页面中会使用到的样式属性值，并编写到一个styl后缀的文件中，当成这些属性值的配置文件使用，这样需要调整相关属性值时就不需要改页面组件了，直接修改这个配置文件即可，

第一步：创建一个color.styl文件，并在里面定义好几个变量

/src/assets/css/color.styl

```
$bgcolor1 = #8B8B00
$bgcolor2 = #8B6508
$bgcolor3 = #ffffff


```

第二步：在页面组件中使用变量

```
<style lang="stylus">
// 引入样式文件
@import('../assets/css/color.styl')
    .page
        width 100vw
        height 100vh
        display flex
        flex-direction column
        .top
            height 50px
            // 使用预定义好的变量
            background-color $bgcolor1
        .middle
            flex 1
            display flex
            .menu
                width 100px
                background-color:$bgcolor2
            .right
                flex 1
                background-color $bgcolor3
            
</style>


```

这样做的好处是，只需要改变变量对应的值，而页面组件中只需要使用变量名即可。

(3)函数的使用

第一步：创建函数文件并编写重复使用的样式代码

创建一个fn.styl文件，里面封装一些函数，把会重复使用到的样式作为函数的内容

/src/assets/css/fn.styl

```
fullscreen(){
    width 100vw
    height 100vh
}


```

第二步：在页面组件中使用函数

```
<style lang="stylus">
// 引入样式文件
@import('../assets/css/fn.styl')
    .page
        fullscreen()
</style>


```

这样在其他页面组件中如果需要使用相同的样式代码时，只需要调用函数名称即可。







# day09

# 一、vuex和本地存储

vuex存储和本地存储(localstorage、sessionstorage)的区别

## 1.区别

vuex存储在内存，localstorage（本地存储）则以文件的方式存储在本地,永久保存；sessionstorage( 会话存储 ) ,临时保存。localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理。

## 2.应用场景

vuex用于组件之间的传值，localstorage则主要用于不同页面之间的传值。

## 3.永久性

当刷新页面时vuex存储的值会丢失，localstorage不会。注：很多同学觉得用localstorage可以代替vuex, 对于不变的数据确实可以，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到响应式，vuex可以绑定数据响应式。
Vuex数据状态持久化的使用场景
(1)购物车
比如你把商品加入购物车后，没有保存到后台的情况下，前端来存，就可以通过这种方式vuex+localStorage(sessionStorage)。

(2)会话状态
授权登录后，token就可以用Vuex+localStorage(sessionStorage)来存储。

(3)一些不会经常改变的数据
比如城市列表等（当前也要留下可以更新的入口，比如版本号）

数据持久化插件：

安装

```
npm install  vuex-persistedstate

```

使用

```
import persistedState from 'vuex-persistedstate'
export default new Vuex.Store({
  getters,
  state,
  actions,
  mutations,
  plugins: [persistedState()]
})

```

# 二、ui库

## 1.element-ui

注意：不要使用element-ui的同时使用bootstrap

### (1)安装

```
npm i element-ui

```

### (2)引入

```
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css';
Vue.use(ElementUI)

```



## 2.mint-ui

官网：

```
http://mint-ui.github.io/#!/zh-cn

```

# 三、版本控制软件git

cvs、svn

## 1.下载安装

官网：https://git-scm.com/

## 2.安装

没有什么特殊要的话直接下一步即可

## 3.使用

### (1)概念

工作区、暂存区、版本库

### (2)基本配置

查看配置

```
git config --list

```

配置必要信息

```
git config --global user.name 用户名
git config --global user.email 邮箱

```

### (3)初始化仓库

进入一个空的目录下或者已有项目的根目录下，执行命令

```
git init

```

创建文件

```
touch 文件名.后缀名

```

创建文件夹

```
mkdir 目录名称

```

git status 查看暂存区状态

### (4)添加文件并提交版本

添加文件到暂存区

```
git add 文件名 添加一个文件
git add *.后缀名 添加一类文件
git add . 添加所有文件和目录

```

提交文件到版本库

```
git commit -m "备注信息"

```

### (5)查看日志

```
git log
git reflog 所有版本记录

```

### (6)版本切换

版本回退到上一个版本

```
git reset --hard HEAD^ 

```

版本回退到上两个版本

```
git reset --hard HEAD^^

```

版本回退到上100个版本

```
git reset --hard HEAD~100

```

版本切换

```
git reset --hard 版本号

```

### (7)对比差异

```
git diff 文件名

```

### (8)撤销修改

```
git checkout 文件名

```

### (9)分支管理

master		主分支，可以对外发布的版本

develop 	开发分支

release		预发布分支

fixed		 修复

...

①查看分支

```
git branch

```

②创建分支

```
git branch 分支名称

```

③切换分支

```
git checkout 分支名称

```

④分支合并

```
git merge 要合并的分支名称

```

# 四、远程协作

github.com

gitee.com 

## 1.注册账号

## 2.创建远程仓库

## 3.添加远程仓库

```
git remote add origin https://github.com/用户名/远程仓库名.git

```

## 4.本地推送到远程仓库

```
git push -u origin master

```

## 5.克隆远程资源

（仅第一次下载项目时执行）

```
git clone https://github.com/用户名/远程仓库名.git


```

## 6.获取远程仓库更新的资源

```
git pull 获取远程仓库的资源，自动的合并到本地
```

```
git fetch 仅获取远程仓库的资源，需要手动的合并
```



# day12

# 一、后台管理系统用户权限验证

## 1.vuex使用

### (1)基础准备

安装

```
npm i vuex
```

创建模块

/src/store/目录下创建以下文件

index.js

state.js

mutation.js

aciton.js

### (2)模块内容

在state.js中设置初始数据

```
export default{
    userinfo:{}
}
```

在mutation.js中封装修改数据的方法

```
export default{
    setUserInfo(state,info){
        state.userinfo = info;
    }
}
```

在action.js中封装异步请求方法

```
import axios from 'axios'
export default{ 
    doLoginSync(context,data){
        return new Promise((reslove,reject)=>{
            axios.post('/api/userlogin',data).then(res=>{
                if(res.data.code==200){
                    context.commit('setUserInfo',res.data.list);
                }
                reslove(res);
            }).catch(err=>{
                reject(err)
            })
        })
    }
}
```

### (3)挂载到vue实例上

在/src/store/index.js中引入以上模块，并暴露出整个store

```
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
import state from './state'
import mutations from './mutation'
import actions from './action'
export default new Vuex.Store({
    state,mutations,actions
})
```

在/src/main.js中引入store

```
import store from './store'
new Vue({
  el: '#app',
  router,
  store,
  components: { App },
  template: '<App/>'
})
```

### (4)在登录页面中调用action中的异步方法

```vue
<template>
    <div class="bg">
        <el-form 
            ref="form" :model="form" label-width="100px"
            :rules="rules"
            class="login"
        >
            <h2 class="h2">登录页面</h2>
            <el-form-item prop="username">
                <el-input placeholder="请输入用户名" v-model="form.username"></el-input>
            </el-form-item>
            <el-form-item prop="password">
                <el-input placeholder="请输入密码" type="password" v-model="form.password"></el-input>
            </el-form-item>
            <el-form-item>
                <el-button type="primary" @click="submit('form')">登录</el-button>
            </el-form-item>
        </el-form>
    </div>
</template>

<script>
export default {
    data(){
        return{
            form:{
                username:'',
                password:''
            },
            rules:{
                username:[
                    { required:true,message:'请填写用户名',trigger:'blur' }
                ],
                password:[
                    { required:true,message:'请填写密码',trigger:'blur' }
                ]
            }
        }
    },
    methods:{
        submit(name){
            this.$refs[name].validate((valid) => {
                if (valid) {
                    this.$store.dispatch('doLoginSync',this.form).then(res=>{
                        if(res.data.code!=200){
                            this.$message(res.data.msg)
                        }else{
                            this.$router.push('/');
                        }
                    })
                }
            });
        }
    }
}
</script>

<style scoped>
.bg{
    width:100%;height: 100%;
    background-color: rgba(0,0,0,0.5);
}
.login{
    width:500px;
    height: 300px;
    background-color: #fff;
    border-radius: 20px;
    margin:0 auto;
    transform: translateY(50%);
}
.h2{ text-align: center; padding:20px 0px;}
.el-form-item{  width:80%;}
.el-button{ width:100%;}
</style>
```

## 2.全局守卫验证登录

vuex仓库中有数据之后，就可以在全局守卫中设置导航钩子函数来验证用户是否登录。

/src/router/index.js

```
//引入仓库
import store from '../store'
let router = new Router({
    routes: [...]
});

router.beforeEach((to,from,next)=>{
    if(to.fullPath === '/login'){
        next();
    }else{
   		//判断仓库中的数据
        var info = store.state.userinfo;
        info.token = info.token ? info.token : null
        //验证用户是否登录
        if(!info.token){
            next('/login')
        }else{
            next();
        }
    }
})

export default router;
```

# 二、axios拦截器的使用

## 1.设置header信息

```
axios({
    url:'接口地址',
    //设置请求头信息
    headers:{
    	Authorization:'令牌信息'
    }
})

```

## 2.封装拦截器

(1)增加默认配置

axios.defaults.headers.common['Authorization'] = token;

这种方式局限性比较大，无法增加一些自定义验证规则或者操作

(2)自行封装方法

在/src/assets/js/目录下创建一个文件：http.js

```javascript
import axios from 'axios'
import store from '../../store'
//直接增加一个配置选项
// axios.defaults.headers.common['Authorization'] = store.state.userinfo.token;

//自行封装方法，这样自定义性更强
function get(url,params={}){
    return new Promise((reslove,reject)=>{
        axios({
            url,
            params,
            headers:{ Authorization:store.state.userinfo.token }
        }).then(res=>{
            reslove(res);
        }).catch(err=>{
            reject(err)
        })
    })
}
function post(url,data){
    return new Promise((reslove,reject)=>{
        axios({
            url,
            data,
            method:'post',
            headers:{ Authorization:store.state.userinfo.token }
        }).then(res=>{
            reslove(res);
        }).catch(err=>{
            reject(err)
        })
    })
}
export default {get,post}

```

在/src/main.js中引入http.js

```
// import axios from 'axios'
import axios from './assets/js/http'
Vue.prototype.$http = axios

```

在页面组件中使用封装好的方法

```javascript
mounted(){
    // this.$http({
    //     url:'/api/menulist?istree=1',
    //     //设置请求头信息
    //     // headers:{
    //     //     Authorization:this.userinfo.token
    //     // }
    // }).then(res=>{
    //     if(res.data.code!=200){
    //         this.$message(res.data.msg)
    //     }else{
    //         this.menuArr = res.data.list;
    //     }

    // })
    this.$http.get('/api/menulist',{istree:1}).then(res=>{
        if(res.data.code!=200){
            this.$message(res.data.msg)
        }else{
            this.menuArr = res.data.list;
        }
    })
}

```

这样封装好公用方法，并在方法中设置了头信息后，页面组件中只要调用方法即可，不用再携带额外的header参数了。





# day14

# 一、数据可视化

## 1.highcharts

(1)官网

http://highcharts.com.cn

(2)基本使用

第一步：引入文件

```
<script src="http://cdn.highcharts.com.cn/highcharts/highcharts.js"></script>

```

第二步：设置一个容器，并设置它的宽度和高度

```
<div id="container" style="width: 600px;height:400px;"></div>

```

第三步：实例化并绘制图表

```javascript
<script>
    // 图表配置
    var options = {
        chart: {
            //指定图表的类型，默认是折线图（line）
            // type: 'bar'                          
        },
        title: {
            // 标题
            text: '我的第一个图表'                 
        },
        // x 轴分类
        xAxis: {
            categories: ['苹果', '香蕉', '橙子']   
        },
        // y 轴标题
        yAxis: {
            title: {
                text: '吃水果个数'                
            }
        },
        // 数据列
        series: [{                              
            name: '小明',                        // 数据列名
            data: [1, 10, 4]                     // 数据
        }, {
            name: '小红',
            data: [5, 7, 3]
        }]
    };
// 图表初始化函数
var chart = Highcharts.chart('container', options);
</script>

```



## 2.echarts

(1)官网

https://echarts.apache.org/zh/index.html

(2)基本使用

第一步：引入文件

```
<script src="https://cdn.jsdelivr.net/npm/echarts@4.9.0/dist/echarts.min.js"></script>

```

第二步：设置容器

```
<div id="main" style="width: 600px;height:400px;"></div>

```

第三步：实例化并绘制图表

```javascript
<script>
    // 基于准备好的dom，初始化echarts实例
    var myChart = echarts.init(document.getElementById('main'));
    // 指定图表的配置项和数据
    var option = {
        title: {
            text: 'ECharts 入门示例'
        },
        tooltip: {},
        legend: {
            data:['销量']
        },
        xAxis: {
            data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
        },
        yAxis: {},
        series: [{
            name: '销量',
            type: 'bar',
            data: [5, 20, 36, 10, 10, 20]
        }]
    };

    // 使用刚指定的配置项和数据显示图表。
    myChart.setOption(option);
</script>

```

在vue中使用

(1)安装

```
npm i echarts

```

(2)引入

```
import echarts from 'echarts'

```

(3)使用

```vue
<template>
    <div>
        <div id="chart"></div>
    </div>
</template>

<script>
import echarts from 'echarts'
export default {
    mounted(){
        var myChart = echarts.init(document.getElementById('chart'));
        // 指定图表的配置项和数据
        var option = {
            title: {
                text: 'web前端学习时长'
            },
            tooltip: {},
            legend: {
                data:['时长']
            },
            xAxis: {
                data: ["css","js","jqery","vue","react","小程序"]
            },
            yAxis: {},
            series: [{
                name: '时长',
                type: 'line',
                data: [25, 30, 10, 15, 5,15]
            }]
        };
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
    }
}
</script>
<style scoped>
    #chart{
        width:1000px;
        height: 600px;
    }
</style>

```

只要提供相应的配置选项和数据，就可以在页面中展示出来相应的图表

## 3.百度地图

(1)注册成为开发者

http://lbsyun.baidu.com/

(2)引入api文件

```
<script type="text/javascript" src="http://api.map.baidu.com/api?v=1.0&type=webgl&ak=你的ak秘钥"></script>

```

(3)创建容器并设置大小

```
<div id="container"></div>

```

样式

```
 <style>
 html,body,#container{
 	width:100%;height:100%;
 }
 </style>

```

(4)初始化地图

```
<script>
    var map = new BMapGL.Map("container");// 创建地图实例 
    var point = new BMapGL.Point(116.404, 39.915);// 创建点坐标 
    map.centerAndZoom(point, 15);// 初始化地图，设置中心点坐标和地图级别
</script>

```

# 二、vue-cli脚手架升级

## 1.卸载原有脚手架

```
npm uninstall vue-cli -g

```

## 2.安装最新版本

```
npm i @vue/cli -g
vue -V 查看脚手架版本号

```

## 3.初始化项目

```
vue create 项目名称

```

初始化过程：

```
? Please pick a preset:
  Default ([Vue 2] babel, eslint)
  Default (Vue 3 Preview) ([Vue 3] babel, eslint)
> Manually select features  自定义

? Check the features needed for your project:
 (*) Choose Vue version
 (*) Babel
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
 (*) Router
 (*) Vuex
 (*) CSS Pre-processors
 ( ) Linter / Formatter
 ( ) Unit Testing
>( ) E2E Testing  
? Choose a version of Vue.js that you want to start the project with (Use arrow keys)
> 2.x
  3.x (Preview) 
 ? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n)n
 
? Where do you prefer placing config for Babel, ESLint, etc.?
  In dedicated config files
> In package.json     
? Save this as a preset for future projects? (y/N) 

```

## 4.运行项目

进入项目根目录，执行如下命令启动项目

```
npm run serve

```

## 5.ui

```
vue ui

```

通过ui就会打开一个图形界面管理项目，通过它可以创建、管理项目

## 6.新脚手架项目配置代理

第一步：在项目根目录下创建一个文件，文件名叫vue.config.js

第二步：在vue.config.js中编写代理转发规格代码

```
module.exports = {
    devServer:{
        proxy:{
            '/api':{
                target:'http://localhost:3000',
                changeOrigin:true
            },
            '/uploads':{
                target:'http://localhost:3000',
                changeOrigin:true
            }
        }
    }
}

```

# 三、服务端渲染

## 1.ssr

### (1)什么是服务端渲染

Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。

### (2)为什么使用服务器端渲染 (SSR)？

优势

- 更好的seo优化
- 更快内容到达

缺点

- 开发条件所限
- 涉及构建设置和部署的更多要求

### (3)代码实现

构建node环境

```
npm init

```

安装依赖

```
npm i vue vue-server-renderer --save

```

将vue模板内容编译成字符串

```
const Vue = require('vue')

const app = new Vue({
    data:{
        msg:'vue ssr 学习'
    },
    template:'<div>hello,{{ msg }}</div>'
})
const renderer = require('vue-server-renderer').createRenderer().renderToString(app,(err,html)=>{
    if(err) throw err;
    console.log(html)
})

```

开启一个服务器，并展示编译后的字符串

```
const Vue = require('vue')
const express = require('express')
const server = express()
const app = new Vue({
    data:{
        msg:'vue ssr 学习'
    },
    template:'<div>hello,{{ msg }}</div>'
})
const renderer = require('vue-server-renderer').createRenderer();
server.get('/index',(req,res)=>{
    renderer.renderToString(app,(err,html)=>{
        if(err) throw err;
        res.end(html)
    })
})
server.listen(3000,()=>{
    console.log('服务运行在3000端口上....')
})

```

结合html模板和模板语法来展示编译后的字符串

```
const Vue = require('vue')
const express = require('express')
const server = express()
const fs = require('fs')
//实例化vue
const app = new Vue({
    data:{
        msg:'vue ssr 学习'
    },
    template:'<div>hello,{{ msg }}</div>'
})
//引入ssr
const renderer = require('vue-server-renderer').createRenderer({
    template:fs.readFileSync('./index.html','utf-8')
});
//设置路由
server.get('/index',(req,res)=>{
    renderer.renderToString(app,(err,html)=>{
        if(err) throw err;
        res.end(html)
    })
})
//监听端口
server.listen(3000,()=>{
    console.log('服务运行在3000端口上....')
})

```

html文件内容：

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!--vue-ssr-outlet-->
</body>
</html>

```

vue-ssr-outlet 是占位符，用来展示编译后的内容。

## 2.nuxt脚手架

(1)npx

```
npm i npx -g

```

(2)create-nuxt-app

```
npm i create-nuxt-app -g

```

(3)初始化项目

```
npx create-nuxt-app 项目名称

```

初始化过程：

```
Generating Nuxt.js project in nuxt-demo
? Project name: nuxt-demo
? Programming language: JavaScript
? Package manager: Npm
? UI framework: None
? Nuxt.js modules: Axios
? Linting tools: (Press <space> to select, <a> to toggle all, <i> to invert selection)
? Testing framework: None
? Rendering mode: Universal (SSR / SSG)
? Deployment target: Server (Node.js hosting)
? Development tools: jsconfig.json (Recommended for VS Code if you're not using typescript)
? What is your GitHub username? ming
? Version control system: Git

```

(4)运行项目

```
npm run dev

```







# day15

# 一、介绍

官网：https://www.tslang.cn/

typescript是javascript超集，由微软开发并开源

它的语法规范、严谨，适合开发大型项目

# 二、环境搭建

## 1.安装

```
npm i typescript -g

```

验证是否安装成功

```
tsc -v

```

## 2.编译

(1)手动编译

创建一个后缀为ts的文件，比如index.ts，并编写js代码

```
tsc index.ts

```

只要执行了编译命令，就会创建一个同名的js出来

(2)自动编译

①创建一个项目，并用ts初始化

初始化好之后就在当前文件夹中存在一个tsconfig.json配置文件

```
tsc --init

```

②修改输出目录

```
"outDir": "./js"

```

③创建js目录，并在vscode菜单栏中找到终端 > 运行生成任务 > tsc监视

在ts文件中编写程序代码，就会自动的生成js文件

# 三、基本使用

## 1.声明变量和数据类型

ts最大的特点就是进行数据类型的验证，要求我们在声明一个变量的时候同时定义好该变量的数据类型。

(1)声明变量

语法格式：

```
var 变量名 : 数据类型名称 //声明变量并确定数据类型
var 变量名 : 数据类型名称 = 内容 //声明变量确定数据类型并直接赋值

```

示例代码：

```
var age : number;//声明一个age变量，并确定数据类型为number
age = 18 //这样进行赋值，没有问题
age = '18' //这样是给age变量赋值一个字符串18，这样就会提示类型不一致

```

(2)数据类型

string、number、boolean、function、object、array...

数组：

```
var 变量名 : Array<数组元素数据类型>

```

示例代码：

```
var users:Array<String>;
users = ['hello'];

```

ts新增数据类型

①元组

```
let 变量名 ： [第一个元素的数据类型名称,第N个元素的数据类型名称]

```

示例代码：

```
let arr1 : [string,number,boolean];
arr1 = ['hello',2000,true]

```

元组的元素数据类型和预定义的数据类型一致才行

②枚举

```
enum 变量名 {值1,值N}

```

示例代码：

```
enum orderStatus { '已下单' = 1,'已发货','已收货' }
console.log(orderStatus.已收货)

```

③any 

任意类型

```
var users2 : Array<any>;
users2 = [100,true,'hello'];
var str : any;//变量类型为any时，就可以给变量设置任何类型的数据
str = 100;str = true;str = ''

```

④void

函数返回值，表示此函数无返回值

⑤never

表示那些不存在的值的类型

```
function error(message:string) : never{
    throw new Error(message);
}

```

## 2.函数

(1)定义

在ts中，定义一个函数，需要函数的返回值类型，如果没有返回值则类型就void，如果函数有参数的话，需要给参数指定数据类型。

语法格式：

```
function 函数名([参数名:参数数据类型]) : 返回值数据类型{...}

```

(2)函数的参数

①默认参数

```
function 函数名(参数名:参数类型 = 默认值) : 返回值数据类型{...}

```

②可选参数

```
function 函数名(参数名:参数类型,[参数名N?:数据类型]) : 返回值数据类型{...}

```

示例代码

```
function getUser(username:string,password?:string):void{
    console.log(username)
    console.log(password)//如果没有传递第二个参数，则是undefined
}
getUser('admin')
getUser('admin','admin123')

```

③剩余参数

```
function 函数名(参数名:参数类型,...参数名N:参数类型) : 返回值数据类型{...}

```

示例代码

```
function getStr(str1:string,...str2:Array<any>):void{
    console.log(str1);
    console.log(str2)
}
getStr('hello','ts','js','vue','react',100,true,{'user':'1111'})

```

调用函数时第一个参数正常传递和接收，其他参数都会被解析成第二个参数（数组类型）

## 3.接口

interface 声明接口

```
interface userinfo{
    username:string,
    age:number,
    phone:number
}
var user1 : userinfo;
user1 = {
    username:'小白',
    age:18,
    phone:12222222222
}

```

## 4.装饰器【重点】

装饰器是一个特殊的类型声明，它可以被附加到类、方法(函数)、属性、参数上面

可以修改类、方法、属性、参数的行为。它就是一个特殊的函数。

### (1)类装饰器

①普通类装饰器

声明

```
function logClass(target:any):void{
	//target 是调用装饰器的类
    target.prototype.phone = 15511112222
}

```

调用

```
//调用装饰器
@logClass
class Person{
    uname:string = '';
}

```

在声明类之前，用@装饰器名称来调用装饰器

②装饰器工厂

普通类装饰器无法传递参数，装饰器工厂可以接收参数，并返回一个装饰器，根据传递的参数就可以改变指定类的行为。

```
//装饰器工厂，可以接收参数
function logClass(params:any){
    return function(target:any):void{
        target.prototype.phone = params;
    }
}
//调用装饰器并传递参数
@logClass(15612345678)
class Person{
    uname:string = '';
}

```

### (2)属性装饰器

声明装饰器

```
function logProperty(target:any,propertyName:any){
    console.log(target,11111) //构造函数
    console.log(propertyName,2222) //属性名称
}

```

调用装饰器

```
class Car{
    @logProperty 声明属性之前调用装饰器
    color : string = '';
}
var c1 = new Car();

```

### (3)方法装饰器

运行时，可以接收三个参数

第一个参数是原型对象

第二个参数是方法的名称

第三个参数是方法的描述

```
function logAction(target:any,methodName:any,desc:any){
    console.log(target,1111)
    console.log(methodName,2222)
    console.log(desc,3333)
}
class Car{
    @logProperty
    color : string = '';

    @logAction //调用方法装饰器
    drive():void{
        console.log('drive....')
    }
}
var c1 = new Car();
c1.drive();

```

### (4)参数装饰器

运行时，可以接收三个参数

第一个参数是原型对象

第二个参数是方法的名称

第三个参数是参数的索引位置

```
class Car{
    color : string = '';
    drive(type:string="mini",@logParam speed:number = 100):void{
        console.log(speed+'drive....')
    }
}
var c1 = new Car();
c1.drive();

```

# 四、ts结合vue-cli脚手架使用

初始化项目

```
vue create ts-demo3
1.选择安装方式
? Please pick a preset:
  Default ([Vue 2] babel, eslint)
  Default (Vue 3 Preview) ([Vue 3] babel, eslint)
> Manually select features  选择自定义方式
2.选择使用的依赖，需要选择哪个就使用空格选中哪个，选择完成后回车
? Check the features needed for your project:
 (*) Choose Vue version
 (*) Babel
 (*) TypeScript
 ( ) Progressive Web App (PWA) Support
 (*) Router
 (*) Vuex
 ( ) CSS Pre-processors
>( ) Linter / Formatter
 ( ) Unit Testing
 ( ) E2E Testing 
3.选择vue版本，选择2.x，3.x选择是预览版
? Choose a version of Vue.js that you want to start the project with (Use arrow keys)
> 2.x
  3.x (Preview) 
4.是否使用类组件语法风格，选择y，回车
? Use class-style component syntax? (Y/n)  y 
5. 是否使用babel ，不使用 n
? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? (Y/n) 
6.是否使用history模式
? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) n 
7.配置文件存放方式，选择package.json
? Where do you prefer placing config for Babel, ESLint, etc.?
  In dedicated config files
> In package.json  
8.是否把以上配置保存作为以后项目默认配置？
? Save this as a preset for future projects? (y/N)  n

```



## 1.定义类方式的组件

```
<script lang="ts">
import { Component,Vue } from 'vue-property-decorator' 
// 定义类方式的组件
@Component({})
export default class Parent extends Vue{

}
</script>

```

## 2.新语法

### (1)定义初始数据

```
<script lang="ts">
import { Component,Vue } from 'vue-property-decorator' 
// 定义类方式的组件
@Component({})
export default class Parent extends Vue{
    msg:string = ''//定义初始数据
}

```

### (2)自定义函数

```vue
<template>
    <div>
        <h2>parent组件</h2>
        <p>{{ msg }}</p>
    </div>
</template>

<script lang="ts">
import { Component,Vue } from 'vue-property-decorator' 
// 定义类方式的组件
@Component({})
export default class Parent extends Vue{
    msg:string = ''//定义初始数据
    changeMsg():void{
        this.msg = '超级天王'//改变初始数据
    }
    //以函数名称的方式来使用生命周期钩子函数
    mounted(){
        this.changeMsg();
    }
}
</script>
<style></style>


```

### (3)计算属性

get 计算属性结果(){...}

```
//计算属性
get newNum():number{
	return this.num + 30;
}


```

### (4)组件通信

①父子组件

子组件通过@Prop装饰器来接收参数

第一步：创建两个页面组件，一个父组件，一个子组件

父组件：

```vue
<template>
    <div>
        <v-child :gift="msg"></v-child>
    </div>
</template>
<script lang="ts">
import { Component,Vue } from 'vue-property-decorator' 
import vChild from './child.vue'
// 定义类方式的组件
@Component({
    components:{ vChild }
})
export default class Parent extends Vue{...}


```

子组件

```vue
<template>
    <div>
        <h3>这是child组件</h3>
        <p>父组件传递的数据：{{ gift }}</p>
    </div>
</template>
<script lang="ts">
import { Component,Vue,Prop } from 'vue-property-decorator'
@Component({})
export default class Child extends Vue{
    @Prop({
        type:String,
        required:true
    })
    gift:string | undefined;
}
</script>


```

②子父组件

在父组件中使用子组件，并传递自定义事件，然后在子组件中通过Emit装饰器来触发父组件的事件

父组件：

```vue
<template>
    <div>
        <p>{{ newNum }}</p>
        <v-child :gift="msg" @changeNum="changeNum"></v-child>
    </div>
</template>
<script lang="ts">
import { Component,Vue } from 'vue-property-decorator' 
import vChild from './child.vue'
// 定义类方式的组件
@Component({
    components:{ vChild }
})
export default class Parent extends Vue{
    num:number = 10;
    changeNum(n:number){
        this.num = n;
    }
}
</script>


```

子组件

```vue
<template>
    <div>
        <button @click="send">发生数据给父组件</button>
    </div>
</template>
<script lang="ts">
import { Component,Vue,Prop,Emit } from 'vue-property-decorator'
@Component({})
export default class Child extends Vue{
    @Emit('changeNum')//触发父组件传递的事件
    send():number{
        return 20;//传递参数给父组件
    }
}
</script>


```





# 第四周react基础

# day16

# 一、react介绍

## 1.官网

https://react.docschina.org/

用于构建用户界面的 JavaScript 库

React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。

## 2.优点

虚拟DOM，性能较好

浏览器兼容性好

一切皆组件

数据单向流动(flux、redux)

jsx语法糖

## 3.缺点

不是一个完整的MVC

# 二、基本使用

## 1.引入核心库

```
<script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
```

## 2.设置挂载点

```
<div id="app"></div>
```

## 3.创建虚拟DOM并渲染

```js
<script>
    // 第三步：创建虚拟DOM，并渲染虚拟DOM
    var el = React.createElement("h1",{},"一寸光阴一寸金")
    ReactDOM.render(
        el,document.getElementById("app")
    )
</script>
```

# 三、JSX语法糖

## 1.基本使用

Javascript and XML

是facebook专门为React开发的一套语法糖，能够实现HTML和JS代码混写

遇到<就解析成html语法，遇到{就解析成js语法

(1)引入babel.js

```
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
```

(2)改变script的type属性

```
<script type="text/babel">
```

script的type属性是text/babel时，才可以解析jsx语法

(3)创建虚拟DOM并渲染

```js
<script type="text/babel">
    var el = <div>
        <h1>一寸光阴一寸金</h1>
        <h2>一寸光阴一寸金</h2>
        <ul>
            <li>1111</li>
    	</ul>
    </div>
    ReactDOM.render(el,document.getElementById("app"))      
</script>
```

## 2.解析变量

在jsx语法中，遇到<就开始解析html语法，遇到{就开始解析js语法

```js
<script type="text/babel">
    var name = '小飞'
    var age = 17
    var el = (<div>
       <h1>一寸光阴一寸金</h1>
       <h2>一寸光阴一寸金</h2>
       <ul>
          <li>1111</li>
       </ul>
       <p>欢迎：{ name }</p>
    	<p>{ 50 + 60 }</p>
    	<p>{ age >= 18 ? '已成年' : '小孩儿' }</p>
    </div>)
    ReactDOM.render(el,document.getElementById("app"))      
</script>
```

在jsx中，不能直接解析布尔值

在jsx中，不能直接解析对象类型数据

## 3.属性绑定

```
<img src={info.photo}/>
```

## 4.样式处理

```
<h1 className="h1" style={ {color:'red',fontSize:'50px'} }>一寸光阴一寸金</h1>

```

在jsx中，行内样式，需要写成一个对象，并且属性名称中带有“-小写字母”要改为大写字母

比如：font-size、background-color等

## 5.条件判断

```js
var isok = true;
// var linkel = null;
// if(isok){
//     linkel = <a>已登录</a>
// }else{
//     linkel = <a>请登录</a>
// }
var linkel = (
    function(){
        if(isok){
            return <a>已登录</a>
        }else{
            return <a>请登录</a>
        }
    }
)();
ReactDOM.render(linkel,document.getElementById("app"));

```



## 6.注意事项

(1)遍历循环时，要个每一个标签添加一个唯一的key属性（在通过diff算法对比时更加高效）

(2)class是js中的关键词，所以使用class时会产生歧义，jsx中class要改为className

(3)for是js中的关键词，所以使用for时会产生歧义，jsx中for要改为htmlFor

(4)所有的标签都要有闭合，像input、img、br、hr等单闭合标签在使用时必须要添加结束符号

(5)虚拟DOM只允许有一个根节点

## 7.常见错误

1.react-dom.development.js:82 Warning: Invalid DOM property `class`. Did you mean `className`?

在react中，使用jsx语法，class是js中声明类的关键词，使用className代替class

2.Uncaught SyntaxError: Inline Babel script: Unterminated JSX contents (34:18)

在jsx中，所有的标签都要有闭合

input、img、br、hr

3.index.js:1 Warning: The tag <home> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.

在react脚手架中，组件的名称要首字母大写

# 四、脚手架

## 1.安装

```
npm i create-react-app -g

```

## 2.初始化项目

```
create-react-app 项目名称

```

## 3.运行项目

```
npm start

```

## 4.目录结构

```
node_modules		项目依赖目录
public				项目访问根目录
src					项目源码目录
	index.js		项目启动文件
	App.js			项目根组件
	index.css		项目全局样式文件
	App.css			项目根组件样式文件

```

public/index.html

src/index.js

src/App.js

自定义组件...

# 五、组件

## 1.类组件

状态组件、业务组件

```js
import React from 'react'
// export default class Home extends React.Component{
class Home extends React.Component{
    render(){
        return(
            <div>
                <h1>home组件</h1>
            </div>
        )
    }
}
export default Home;

```

## 2.函数组件

无状态组件

```javascript
import React from 'react'
let order = ()=>{
    return(
        <div>
            <h1>order组件</h1>
        </div>
    )
}
export default order;

```

# 六、状态机

在类组件中，默认有一个state配置选项（状态机），它的初始值是null

如果需要展示一个数据，修改数据后，并让页面重新渲染，那么需要把这个数据放到状态机中。

## 1.构造函数中定义state

```js
class Home extends Component{
    constructor(){
        super()//必须要先写super，可以在其后面获取this指向
        this.state = {
            time:new Date().toLocaleTimeString()
        }
    }
}
export default Home

```

## 2.类中定义state

```javascript
class Home extends Component{
	state = {
		time:new Date().toLocaleTimeString()
	}
}

```

## 3.修改state

react中专门提供了一个用来修改state状态机数据的方法setState

setState完成的两件事情：

- 把指定的数据与状态机中已有的数据进行合并

- 重新调用render方法进行页面渲染

```javascript
constructor(){
    super()//必须要先写super，可以在其后面获取this指向
    //初始化状态机
    this.state = { time:'' };
    setInterval(()=>{
        // this.state.time = new Date().toLocaleTimeString()
       	//上面的方式，数据会发生变化，但是页面内容不变
        //采用setState方式进行数据的变化并重新渲染页面
        this.setState({
            time:new Date().toLocaleTimeString()
        })
    },1000)
}

```

# 七、事件

基础示例代码：

```
state = {
    num : 100
}
changeNum(){
    console.log("changeing....")
    console.log(this)
}
render(){
    return(
        <div>
            <h2>数量：{ this.state.num }</h2>
            <button onClick={ this.changeNum }>点击改变</button>
        </div>

    )
}

```

## 1.事件绑定

(1)es5

在jsx的虚拟DOM中，事件绑定调用函数时，如果加了括号，则指定的函数会自动的触发

指定的函数中this是undefined，如果需要在函数中获取this，需要使用bind来进行绑定

```
<button onClick={ this.changeNum.bind(this) }>点击改变</button>

```

(2)es6

```
<button onClick={ ()=> this.changeNum() }>点击改变-es6</button>

```

使用箭头函数，可以保持this指向

## 2.事件对象

(1)es5

```
changeNum2(event){
	console.log(event)
}
render(){
	return(
		<button onClick={ this.changeNum2 }>事件对象-es5</button>
	)
}

```

es5方式调用函数，如果没有显示的传递实参，但在函数中有一个形参，那么这个形参就是事件对象

(2)es6

```
<button onClick={ (ev)=> this.changeNum2(ev) }>事件对象-es6</button>

```

es6方式需要主动的传递事件对象，然后在函数中才能够获取到对应的事件对象。

## 3.参数传递

(1)es5

```
<button onClick={ this.changeNum3.bind(this,10) }>参数传递-es5</button>

```

如果绑定来this并显示的传递了额外的参数，那么函数中的第一个形参，就是this后面传递的数据

如果此时还要在函数中获取事件对象，那么就在所有的形参的后面再增加一个形参，这个形参就是事件对象。

```
changeNum3(num,e,str){
    console.log(num,'num')
    console.log(e,'event')
    console.log(str,'str')
}

```

(2)es6

```
<button onClick={ (ev)=> this.changeNum3(100,ev,'reactjs') }>参数传递-es6</button>

```

es6方式传递参数，参数传递的顺序和函数参数接收的一致。

## 4.模拟表单元素双向绑定

结合事件绑定、事件传参、状态机可以实现像vue中v-model双向绑定的效果

```javascript
import React,{ Component } from 'react'
export default class Form extends Component{
    state = {
        ipt:'',
        phone:''
    }
    iptChange(e,type){
        console.log(e.target.value)
        // this.setState({
        //     ipt:e.target.value,
        // })
        var data = this.state;
        data[type] = e.target.value;
        this.setState(data)
    }
    render(){
        return(
            <div>
                <div>
                    <label>用户名：</label>
                    {/* 非受控组件，onChange 受控组件 */}
                    <input type="text" value={ this.state.ipt } onChange={ (e)=>this.iptChange(e,'ipt') }/>
                    <p>{ this.state.ipt }</p>
                </div>
                <div>
                    <label>手机号：</label>
                    <input type="text" value={ this.state.phone } onChange={ (e)=>this.iptChange(e,'phone') }/>
                    <p>{ this.state.phone }</p>
                </div>
            </div>
        )
    }
}

```







# day17	

# 一、状态机进阶

setState它是一个异步操作，所以在使用完setState之后马上再从state中获取数据，获取到的不是最新的数据，如果需要获取到最新的数据，可以给setState传递第二个参数

```js
import React, { Component } from 'react'
export default class Home extends Component {
    state = { num:100}
    addNum(){
        var num = this.state.num;
        num++;
        this.setState({num})
        console.log(this.state.num,1111111);//此时获取到的数据不是最新
    }
    render() {
        return (
            <div>
                <h1>home组件--{ this.state.num }</h1>
                <button onClick={ ()=>this.addNum() }>点击增加num</button>
            </div>
        )
    }
}


```

使用setState的第二个参数，传递一个回调函数，当setState更新完数据后，马上会触发回调函数

```js
addNum(){
    var num = this.state.num;
    num++;
    this.setState({num},()=>{
        console.log(this.state.num,222222);//此时获取到的就是最新的数据
    })
    console.log(this.state.num,1111111);//此时获取到的数据不是最新
}

```

# 二、组件通信【重点】

## 1.父子组件

在父组件中，使用子组件时，通过自定义属性传递数据

在子组件中，通过props接收父组件传递的数据

父组件：

```js
import React, { Component } from 'react'
import Item from './Item'
export default class Parent extends Component {
    state = {
        msg : '天道酬勤'
    }
    render() {
        return (
            <div>
                <h1>parent组件</h1>
                <hr/>
                <Item msg={ this.state.msg }></Item>
            </div>
        )
    }
}

```

子组件：

(1)函数组件

```js
import React from 'react'
let Item = (props)=>{
    return(
        <div>
            <h2>item组件--{ props.msg }</h2>
        </div>
    )
}
export default Item;

```

函数组件主要通过参数来接收父组件传递的数据，参数名称叫props可以更好的理解它是传递过来的数据。

(2)类组件

```js
import React,{ Component } from 'react'
class Item extends Component{
    render(){
        return(
            <div>
                <h2>item组件--{ this.props.msg }</h2>
            </div>
        )
    }
}
export default Item;

```

类组件直接通过this中的props属性来获取父组件传递的数据，它是组件中自带的一个属性，其数据类型是对象，表示可以接收传递的多个数据。

## 2.子父组件

父组件通过传递自定义事件给子组件，在子组件中触发父组件的事件，实现数据的传递

### (1)父组件

定义好函数方法

```js
delItem(n){
    //先读取状态机中的数据
    var data = this.state.arr;
    //进行数据删除操作
    data.splice(n,1)
    //删除成功后，再把数据赋值给状态机
    this.setState({
        arr:data
    })
}

```

通过子组件，传递事件

```js
render() {
    return (
        <div>
            <h1>parent组件</h1>
            <hr/>
            {
                this.state.arr.map((d,index)=>{
            // handlerDel={ (m)=>this.delItem(m) } 传递事件给子组件并接收子组件传递的参数
                return(
                    <Item 
                        obj={ d } 
                        key={ index } 
                        handlerDel={ (m)=>this.delItem(m) }
                    idx={ index }
                    ></Item>
                )
            })
    	}
        </div>
	)
}

```

### (2)子组件

通过props来触发父组件传递过来的事件函数，并传递参数

```js
import React,{ Component } from 'react'
import './Item.css'
class Item extends Component{
    del(){
        //触发父组件传递的事件函数，并传递参数
        this.props.handlerDel(this.props.idx);
    }
    render(){
        return(
            <div className="item">
                <h2>{ this.props.obj.title }</h2>
                <p>{ this.props.obj.content }</p>
                <button onClick={ ()=>this.del() }>删除</button>
            </div>
        )
    }
}
export default Item;

```

## 3.非父子组件

定义一个公用容器

/src/bus.js

```js
const EventEmitter = require('events');
class MyEmitter extends EventEmitter {}
export default new MyEmitter();


```

把公用容器挂载到Component的原型上

/src/index.js

```js
import bus from './bus'
Component.prototype.bus = bus;


```

发送数据组件 公用容器.emit('事件',数据)

```js
this.bus.emit('事件名称',要发送的数据);


```

接收数据组件 公用容器.on('事件',(参数)=>{})

```js
constructor(){
    super();
    this.bus.on('事件名称',(参数)=>{...})
}


```

# 三、生命周期【重点】

只有类组件才有生命周期

<img src="E:/Myweb/stage4/day17/notes/生命周期.jpg" />

## 1.页面渲染期

constructor										构造函数

UNSAFE_componentWillMount	 组件将要挂载

render												组件渲染

componentDidMount					  组件挂载完成

同步的请求，可以放在UNSAFE_componentWillMount

异步的请求，一般放在componentDidMount

## 2.页面更新期

shouldComponentUpdate		组件是否要更新数据，需要返回一个布尔值，如果是true则更新

UNSAFE_componentWillUpdate  组件数据将要更新，shouldComponentUpdate返回的是true

render										  页面渲染，shouldComponentUpdate返回的是true

componentDidUpdate			  组件数据更新完成，shouldComponentUpdate返回的是true

UNSAFE_componentWillReceiveProps	子组件将要接收父组件传递的最新数据，shouldComponentUpdate返回的是true

## 3.页面销毁期

componentWillUnmount		组件销毁（页面不在显示）

# 四、state和props混用

state是组件的初始数据，在组件中可以对state中的数据进行任意修改

props是父组件传递过来的数据，子组件只能读取props中的数据，不能直接修改props中数据。

有时在子组件中，需要把父组件传递过来的数据当成自己页面中的数据进行使用，会存在一个数据不同步的问题。

父组件：

```js
import React, { Component } from 'react'
import Item from './Item'
export default class Home extends Component {
    state = {
        num:100
    }
    componentDidMount(){
        console.log('父组件挂载完成...')
        this.setState({
            num:200
        })
    }
    render() {
        return (
            <div>
                <h1>home组件---{ this.state.num }</h1>
                <hr/>
                <Item data={ this.state.num }></Item>
            </div>
        )
    }
}



```

子组件：

```js
import React, { Component } from 'react'

export default class Item extends Component {
    state = { num : 0 }
    componentDidMount(){
        console.log('子组件挂载完成...')
        this.setState({
            num:this.props.data
        })
    }
    render() {
        return (
            <div>
                <h2>item组件--{ this.state.num }</h2>
            </div>
        )
    }
}



```

此时会产生一个数据不同步的问题

为了解决这个问题，我们可以在子组件执行setState时，把第一个参数由对象改为函数

setState

​	第一个参数是对象，直接修改数据

​	第二个参数是回调函数

​	第一个是函数，函数中接收两个参数，第一个参数是页面自己的数据，第二个参数是父组件传递的最新数据

```js
import React, { Component } from 'react'
export default class Item extends Component {
    state = { num : 0 }
    componentDidMount(){
        console.log('子组件挂载完成...')
        // this.setState({
        //     num:this.props.data
        // })
        this.setState(function(state,props){
            state.num = props.data;
        })
    }
    render() {
        return (
            <div>
                <h2>item组件--{ this.state.num }</h2>
            </div>
        )
    }
}



```

# 五、DOM节点操作

ref

## 1.字符串

```
<h1 ref="myh1"></h1>

this.refs.myh1.style.color = 'red'


```

## 2.回调函数

```
<h1 ref={ (e)=>this.getRef(e) }>home组件---{ this.state.num }</h1>


```

回调函数会自动触发，如果传递了参数，那么这个就是标签本身

## 3.createRef API

在构造函数中使用React.createRef方法，在React中推荐使用这种方式实现DOM节点操作

```
 constructor(){
     super();
     this.childEl = React.createRef();
 }


```

在普通标签或者子组件上添加ref属性

```
<Item ref={ this.childEl } data={ this.state.num }></Item>


```

在挂载完成的生命周期中对子组件进行处理

```js
componentDidMount(){
    //给子组件增加新的属性
    this.childEl.current.state.msg = 'parent data';
    //改变子组件已有的数据，并通过状态机重新渲染页面
    this.childEl.current.setState({
        num:500
    })
 }


```

createRef作用在函数组件上无效果

# 六、路由

React开发出来的也是SPA单页面应用，可以使用路由（react-router-dom）来实现多页面的切换。

## 1.安装

```
npm i react-router-dom --save


```

## 2.引入

/src/index.js

引入路由模式组件

```js
import { BrowserRouter } from 'react-router-dom'
ReactDOM.render(
    <BrowserRouter><App /></BrowserRouter>,
    document.getElementById('root')
);


```

## 3.基本使用

(1)创建几个页面组件

(2)引入需要通过路由地址展示的页面组件

```js
import Home from './components/Home'
import Order from './components/Order'
import My from './components/My'


```

(3)在App.js中引入路由出口和路由规则组件，并定义路由规则

```js
import { Switch,Route } from 'react-router-dom'
function App() {
    return (
        <div className="App">
            <Switch>
                <Route path="/home" component={ Home }></Route>
                <Route path="/order" component={ Order }></Route>
                <Route path="/my" component={ My }></Route>
            </Switch>
        </div>
    );
}

export default App;


```

## 2.重定向

Redirect

引入重定向组件

```
import { Switch,Route,Redirect } from 'react-router-dom'


```

定义重定向路由规则

```
<Redirect path="*" to="/home"></Redirect>


```

## 3.路由导航

### (1)内置组件

```
import { Switch,Route,Redirect,Link,NavLink } from 'react-router-dom'


```

Link、NavLink

这两个组件都会在页面上生成a标签，都需要设置to属性

NavLink对当访问的路由地址，会给对应的标签设置一个激活状态的类名

```js
<div className="App">
    <Link to="/home">首页</Link>
    <Link to="/order">订单</Link>
    <br/>
    <NavLink to="/home">首页</NavLink>
    <NavLink to="/order">订单</NavLink>
    <NavLink to="/my">个人中心</NavLink>
    <Switch>
        <Route path="/home" component={ Home }></Route>
        <Route path="/order" component={ Order }></Route>
        <Route path="/my" component={ My }></Route>
        <Redirect path="*" to="/home"></Redirect>
    </Switch>
</div>


```



### (2)编程式导航

this.props.history

push

replace

go(-1)

goBack









# day18

# 一、路由

## 1.路由嵌套

在指定的页面中，如果再需要展示不同的子级页面，需要用到路由嵌套。

和vue不同的是，在react中，需要在哪个页面展示子级页面，就在哪个页面中写Switch路由出口和Route路由规则。

在Index.js中先引入需要展示的子级页面，并定义好路由规则

```js
import React, { Component } from 'react'
import { Switch,Route,NavLink,Redirect } from 'react-router-dom'
import './Index.css'
//引入需要展示的子级页面
import Student from './Student'
import Course from './Course'
export default class Index extends Component {
    render() {
        return (
            <div className="page">
                <div className="top">top</div>
                <div className="main">
                    <div className="left">
                        <NavLink to="/home/student">学生管理</NavLink>
                        <NavLink to="/home/course">课程管理</NavLink>
                    </div>
                    <div className="right">
                        <Switch>
                            {/* 定义二级页面的路由规则 */}
                            <Route path="/home/student" component={ Student }></Route>
                            <Route path="/home/course" component={ Course }></Route>
                            <Redirect path="*" to="/home/student"></Redirect>
                        </Switch>
                    </div>
                </div>
            </div>
        )
    }
}


```

需要在哪个页面展示子级页面，就在哪个页面引入页面组件、Switch、Route，并在该页面定义路由规则，如果有多个页面要展示不同的子级页面，就需要一直重复刚才的操作。

为了更好的实现组件的复用，提高项目的可维护性，把Switch封装成一个单独的组件，根据传递的数据生成具体的路由规则。

(1)创建一个公用的组件

/src/router/index.js

```js
import React from 'react'
import { Switch,Route } from 'react-router-dom'
let router = (props)=>{
    return(
        <Switch>
            {
                props.data.map((item,index)=>{
                    return(
                        <Route key={ index } path={ item.path } component={ item.component }></Route>
                    )
                })
            }
        </Switch>
    )
}
export default router;

```

(2)定义不同级别的路由规则（仿照vue-router方式）

一级路由规则

/src/router/AppRoutes.js

```js
import Index from '../components/Index'
import Login from '../components/Login'
var routes = [
    {
        path:'/index',
        component:Index
    },
    {
        path:'/login',
        component:Login
    }
]
export default routes;

```

二级路由规则

/src/router/IndexRoutes.js

```js
import Student from '../components/Student'
import Course from '../components/Course'
let routes = [
    {
        path:'/index/student',
        component:Student
    },
    {
        path:'/index/course',
        component:Course
    }
]
export default routes;

```

(3)在App.js中使用公用的组件

```js
//引入路由配置规格数据
import AppRoutes from './router/AppRoutes'
//引入公用组件
import MyRouter from './router'
function App() {
    return (
        <div className="App">
            <MyRouter data={ AppRoutes }></MyRouter>
        </div>
    );
}
export default App;

```

这样，在App.js中就不需要写Switch和Route来定义路由规则了，只需要引入公用组件，并传入路由规则数据即可。

(4)在首页中引入公用的组件

```js
import React, { Component } from 'react'
import { NavLink } from 'react-router-dom'
import './Index.css'
import IndexRoutes from '../router/IndexRoutes'
import MyRouter from '../router'
export default class Index extends Component {
    render() {
        return (
            <div className="page">
                <div className="top">top</div>
                <div className="main">
                    <div className="left">
                        <NavLink to="/index/student">学生管理</NavLink>
                        <NavLink to="/index/course">课程管理</NavLink>
                    </div>
                    <div className="right">
                        <MyRouter data={ IndexRoutes }></MyRouter>
                    </div>
                </div>
            </div>
        )
    }
}

```

## 2.高阶组件

withRouter

在react的路由中，==只有路由规则对应的页面组件==才有路由相关的信息，页面组成部分组件没有路由信息，如果在路由规则对应的页面组件组成部分中使用props.history中的相关API方法时，需要使用withRouter这个高阶组件。

```js
import { NavLink,withRouter } from 'react-router-dom'
class Menu extends Component{
    logout(){
        this.props.history.push('/login')
    }
    render(){
        return(
            <div className="left">
                <NavLink to="/index/student">学生管理</NavLink>
                <NavLink to="/index/course">课程管理</NavLink>
                <button onClick={ ()=>this.logout() }>退出</button>
            </div>
        )
    }
}
export default withRouter(Menu);

```

用withRouter包裹的组件，会默认保持上一级页面的路由信息

## 3.路由传参

(1)动态路由

①定义详情页面组件

②定义动态路由规则

```
{
    path:'/index/student/:id',
    component:StudentInfo
}

```

和vue定义动态路由方式一模一样，都是在路由规则中使用冒号加上参数名称

③列表页面进行跳转

```
toInfo(id){
	this.props.history.push('/index/student/'+id)
}

```

④获取动态路由参数

```
<p>编号：{ this.props.match.params.id }</p>

```

(2)查询参数

如果参数数量不固定时，就不能使用动态路由了，需要使用查询参数

①定义路由规则

```
{
    // path:'/index/student/:id',
    path:'/index/student/info',
    component:StudentInfo
}

```

②列表页面进行跳转

```
this.props.history.push('/index/student/info/?id=' + obj.id + '&name='+obj.name)

```

③获取路由参数

```
this.props.search

```

这种方式需要自己手动拼接参数地址，在详情页获取到的是一个字符串，还需要进行处理才能获取到想要的数据，为了方便使用，引入querystring插件

```
npm i querystring

```

在页面中引入并使用

```js
import qs from 'querystring'
toInfo(obj){
    this.props.history.push('/index/student/info?' + qs.stringify(obj))
}

```

通过querystring的stringify方法，就可以自动把对象转换成字符串格式“参数名=参数值&参数名N=参数值N”

在详情页面获取查询参数

```
querystring.parse(this.props.location.search.substring(1))


```

这样就可以得到一个对象，想获取什么数据就直接从对象中获取即可。

querystring.parse的作用是把“参数名=参数值&参数名N=参数值N”格式的字符串转换成对象

## 4.路由模式

在src/index.js中引入HashRouter，并用它把App包裹起来

HashRouter 哈希模式

BrowserRouter history模式

```js
import React from 'react';
import ReactDOM from 'react-dom';
// import { BrowserRouter } from 'react-router-dom'
import { HashRouter } from 'react-router-dom'
import './index.css';
import App from './App';
ReactDOM.render(
    // <BrowserRouter><App /></BrowserRouter>,
    <HashRouter><App /></HashRouter>,
    document.getElementById('root')
);

```

# 二、状态管理

## 1.flux

flux是facebook为React开发一套状态管理的架构模式

流程：

​	view	触发	action

​	action 通知 dipatcher(派发器) 派发任务

​	dispathcer 通知仓库修改数据

​	仓库完成数据之后通过页面进行重新渲染

<img src="E:/Myweb/stage4/day18/笔记/flux.png" />

(1)创建仓库

/src/store/index.js

```
let state = {
    name : 'flux name'
}
export default { state }

```

(2)在任意页面组件中使用仓库

```js
import React, { Component } from 'react'
//引入仓库
import store from './store'
export default class Home extends Component {
    render() {
        return (
            <div>
                <h1>home组件</h1>
                <h2>仓库中的name是：{ store.state.name }</h2>
            </div>
        )
    }
}

```

(3)引入flux中的派发器，规定好数据可预测性变化的方法

/src/store/index.js

```js
import { Dispatcher } from 'flux'
let dispatcher = new Dispatcher();
//注册好具体的派发任务
dispatcher.register(action=>{
    switch(action.type){
        case 'changeName':
            state.name = action.params;
            break;
        default:
            break;
    }
});
export default { state,dispatcher }

```

(4)在页面组件中通过仓库的派发器派发任务

```js
 changeName(){
     //调用仓库中的方法来修改数据
     store.dispatcher.dispatch({
         type:'changeName',
         params:'new name'
     })
 }

```

但是，此时仓库中的数据会变化，页面组件并没有重新渲染

在仓库中引入事件监听器，通知页面数据变化后刷新页面

①仓库引入事件监听器

```js
//引入事件监听器
import EventEmitter from 'events'
class State extends EventEmitter{
    name = 'flux name'
    age = 18
}
let state = new State();
let dispatcher = new Dispatcher();
//注册好具体的派发任务
dispatcher.register(action=>{
    switch(action.type){
        case 'changeName':
            state.name = action.params;
            break;
        case 'changeAge':
            state.age = action.params;
            break;
        default:
            break;
    }
    //触发事件，通知页面重新渲染
    state.emit('change')
});

```

②页面组件中触发action，并监听事件

```
componentDidMount(){
    store.state.on('change',()=>{
    	this.setState({})
    })
}


```



## 2.redux

​	Redux由Dan Abramov在2015年创建的科技术语。是受2014年Facebook的Flux架构以及函数式编程语言Elm启发。很快，Redux因其简单易学体积小在短时间内成为最热门的前端架构。

   Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers）。

redux三个原则：

单一数据源

state是只读的

使用纯函数来修改state

(1)安装

```
npm i redux --save

```

(2)基本使用

流程：

引入createStore、定义初始状态、定义纯函数、定义仓库

示例代码：

/src/store/index.js

```js
// redux仓库
import { createStore } from 'redux'
//初始化状态
const initalState = {name:'小王',age:18}
//定义纯函数
function reducer(state = initalState,action){
    switch(action.type){
        case 'changeName':
            return{
                ...state,
                name:action.params
            }
        case 'changeAge':
            return{
                ...state,
                age:action.params
            }
        default:
            return state;
    }
}

//创建仓库
const store = createStore(reducer);
export default store;

```

页面组件使用仓库中的状态

```
<h2>redux-仓库中的name为:{ store.getState().name }</h2>
<h2>redux-仓库中的age为:{ store.getState().age }</h2>

```

修改仓库中的状态

```js
changeName(){
    //调用仓库中的方法来修改数据
    store.dispatch({
        type:'changeName',
        params:'王飞'
    })
}

```

使用订阅者来检测仓库数据的变化，实现页面重新渲染

```js
componentDidMount(){
    store.subscribe(()=>{
        this.setState({})
    })
}

```

# 三、代理配置

修改端口号：node_modules\react-scripts\scripts\start.js

## 1.修改package.json

```
"proxy":"http://localhost:3000"

```

==重启项目==让配置文件生效

在页面组件中发起网络请求

```js
componentDidMount(){
    fetch('/api/getCate').then(res=>{
        console.log(res)
    })
}

```

此时就可以执行跨域请求了

## 2.第三方插件

http-proxy-middleware

先把package.json配置的proxy选项去掉，直接删除。

安装：

```
npm i http-proxy-middleware --save

```

在src目录下创建一个setupProxy.js文件【名字不能写错】

编写内容：

```js
const proxy = require('http-proxy-middleware')
module.exports = function(app){
    app.use(proxy.createProxyMiddleware('/api',{
        target:'http://localhost:3000',
        changeOrigin:true
    }));
    app.use(proxy.createProxyMiddleware('/uploads',{
        target:'http://localhost:3000',
        changeOrigin:true
    }))
}

```

==重启项目！！！==

重新启动项目后，代理配置生效

# 五、ui库

antd

官网：

https://ant.design/index-cn

移动端：

https://xtech.antfin.com/

